
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPhoto
 * 
 */
export type UserPhoto = $Result.DefaultSelection<Prisma.$UserPhotoPayload>
/**
 * Model WardrobeItem
 * 
 */
export type WardrobeItem = $Result.DefaultSelection<Prisma.$WardrobeItemPayload>
/**
 * Model Outfit
 * 
 */
export type Outfit = $Result.DefaultSelection<Prisma.$OutfitPayload>
/**
 * Model OutfitItem
 * 
 */
export type OutfitItem = $Result.DefaultSelection<Prisma.$OutfitItemPayload>
/**
 * Model RenderJob
 * 
 */
export type RenderJob = $Result.DefaultSelection<Prisma.$RenderJobPayload>
/**
 * Model CreditsLedger
 * 
 */
export type CreditsLedger = $Result.DefaultSelection<Prisma.$CreditsLedgerPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Usage
 * 
 */
export type Usage = $Result.DefaultSelection<Prisma.$UsagePayload>
/**
 * Model EventAnalytics
 * 
 */
export type EventAnalytics = $Result.DefaultSelection<Prisma.$EventAnalyticsPayload>
/**
 * Model HelpCenterConversation
 * 
 */
export type HelpCenterConversation = $Result.DefaultSelection<Prisma.$HelpCenterConversationPayload>
/**
 * Model HelpCenterMessage
 * 
 */
export type HelpCenterMessage = $Result.DefaultSelection<Prisma.$HelpCenterMessagePayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userPhoto`: Exposes CRUD operations for the **UserPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhotos
    * const userPhotos = await prisma.userPhoto.findMany()
    * ```
    */
  get userPhoto(): Prisma.UserPhotoDelegate<ExtArgs>;

  /**
   * `prisma.wardrobeItem`: Exposes CRUD operations for the **WardrobeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WardrobeItems
    * const wardrobeItems = await prisma.wardrobeItem.findMany()
    * ```
    */
  get wardrobeItem(): Prisma.WardrobeItemDelegate<ExtArgs>;

  /**
   * `prisma.outfit`: Exposes CRUD operations for the **Outfit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outfits
    * const outfits = await prisma.outfit.findMany()
    * ```
    */
  get outfit(): Prisma.OutfitDelegate<ExtArgs>;

  /**
   * `prisma.outfitItem`: Exposes CRUD operations for the **OutfitItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutfitItems
    * const outfitItems = await prisma.outfitItem.findMany()
    * ```
    */
  get outfitItem(): Prisma.OutfitItemDelegate<ExtArgs>;

  /**
   * `prisma.renderJob`: Exposes CRUD operations for the **RenderJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RenderJobs
    * const renderJobs = await prisma.renderJob.findMany()
    * ```
    */
  get renderJob(): Prisma.RenderJobDelegate<ExtArgs>;

  /**
   * `prisma.creditsLedger`: Exposes CRUD operations for the **CreditsLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditsLedgers
    * const creditsLedgers = await prisma.creditsLedger.findMany()
    * ```
    */
  get creditsLedger(): Prisma.CreditsLedgerDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.usage`: Exposes CRUD operations for the **Usage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usages
    * const usages = await prisma.usage.findMany()
    * ```
    */
  get usage(): Prisma.UsageDelegate<ExtArgs>;

  /**
   * `prisma.eventAnalytics`: Exposes CRUD operations for the **EventAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventAnalytics
    * const eventAnalytics = await prisma.eventAnalytics.findMany()
    * ```
    */
  get eventAnalytics(): Prisma.EventAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.helpCenterConversation`: Exposes CRUD operations for the **HelpCenterConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCenterConversations
    * const helpCenterConversations = await prisma.helpCenterConversation.findMany()
    * ```
    */
  get helpCenterConversation(): Prisma.HelpCenterConversationDelegate<ExtArgs>;

  /**
   * `prisma.helpCenterMessage`: Exposes CRUD operations for the **HelpCenterMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCenterMessages
    * const helpCenterMessages = await prisma.helpCenterMessage.findMany()
    * ```
    */
  get helpCenterMessage(): Prisma.HelpCenterMessageDelegate<ExtArgs>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserPhoto: 'UserPhoto',
    WardrobeItem: 'WardrobeItem',
    Outfit: 'Outfit',
    OutfitItem: 'OutfitItem',
    RenderJob: 'RenderJob',
    CreditsLedger: 'CreditsLedger',
    Subscription: 'Subscription',
    Purchase: 'Purchase',
    Usage: 'Usage',
    EventAnalytics: 'EventAnalytics',
    HelpCenterConversation: 'HelpCenterConversation',
    HelpCenterMessage: 'HelpCenterMessage',
    NotificationSettings: 'NotificationSettings',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userPhoto" | "wardrobeItem" | "outfit" | "outfitItem" | "renderJob" | "creditsLedger" | "subscription" | "purchase" | "usage" | "eventAnalytics" | "helpCenterConversation" | "helpCenterMessage" | "notificationSettings" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPhoto: {
        payload: Prisma.$UserPhotoPayload<ExtArgs>
        fields: Prisma.UserPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findFirst: {
            args: Prisma.UserPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findMany: {
            args: Prisma.UserPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>[]
          }
          create: {
            args: Prisma.UserPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          createMany: {
            args: Prisma.UserPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>[]
          }
          delete: {
            args: Prisma.UserPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          update: {
            args: Prisma.UserPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          deleteMany: {
            args: Prisma.UserPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          aggregate: {
            args: Prisma.UserPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhoto>
          }
          groupBy: {
            args: Prisma.UserPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoCountAggregateOutputType> | number
          }
        }
      }
      WardrobeItem: {
        payload: Prisma.$WardrobeItemPayload<ExtArgs>
        fields: Prisma.WardrobeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardrobeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardrobeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          findFirst: {
            args: Prisma.WardrobeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardrobeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          findMany: {
            args: Prisma.WardrobeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>[]
          }
          create: {
            args: Prisma.WardrobeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          createMany: {
            args: Prisma.WardrobeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardrobeItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>[]
          }
          delete: {
            args: Prisma.WardrobeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          update: {
            args: Prisma.WardrobeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          deleteMany: {
            args: Prisma.WardrobeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardrobeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardrobeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardrobeItemPayload>
          }
          aggregate: {
            args: Prisma.WardrobeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWardrobeItem>
          }
          groupBy: {
            args: Prisma.WardrobeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardrobeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardrobeItemCountArgs<ExtArgs>
            result: $Utils.Optional<WardrobeItemCountAggregateOutputType> | number
          }
        }
      }
      Outfit: {
        payload: Prisma.$OutfitPayload<ExtArgs>
        fields: Prisma.OutfitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutfitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutfitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          findFirst: {
            args: Prisma.OutfitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutfitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          findMany: {
            args: Prisma.OutfitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>[]
          }
          create: {
            args: Prisma.OutfitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          createMany: {
            args: Prisma.OutfitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutfitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>[]
          }
          delete: {
            args: Prisma.OutfitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          update: {
            args: Prisma.OutfitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          deleteMany: {
            args: Prisma.OutfitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutfitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutfitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          aggregate: {
            args: Prisma.OutfitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutfit>
          }
          groupBy: {
            args: Prisma.OutfitGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutfitGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutfitCountArgs<ExtArgs>
            result: $Utils.Optional<OutfitCountAggregateOutputType> | number
          }
        }
      }
      OutfitItem: {
        payload: Prisma.$OutfitItemPayload<ExtArgs>
        fields: Prisma.OutfitItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutfitItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutfitItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          findFirst: {
            args: Prisma.OutfitItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutfitItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          findMany: {
            args: Prisma.OutfitItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>[]
          }
          create: {
            args: Prisma.OutfitItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          createMany: {
            args: Prisma.OutfitItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutfitItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>[]
          }
          delete: {
            args: Prisma.OutfitItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          update: {
            args: Prisma.OutfitItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          deleteMany: {
            args: Prisma.OutfitItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutfitItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutfitItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitItemPayload>
          }
          aggregate: {
            args: Prisma.OutfitItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutfitItem>
          }
          groupBy: {
            args: Prisma.OutfitItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutfitItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutfitItemCountArgs<ExtArgs>
            result: $Utils.Optional<OutfitItemCountAggregateOutputType> | number
          }
        }
      }
      RenderJob: {
        payload: Prisma.$RenderJobPayload<ExtArgs>
        fields: Prisma.RenderJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RenderJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RenderJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          findFirst: {
            args: Prisma.RenderJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RenderJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          findMany: {
            args: Prisma.RenderJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>[]
          }
          create: {
            args: Prisma.RenderJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          createMany: {
            args: Prisma.RenderJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RenderJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>[]
          }
          delete: {
            args: Prisma.RenderJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          update: {
            args: Prisma.RenderJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          deleteMany: {
            args: Prisma.RenderJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RenderJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RenderJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenderJobPayload>
          }
          aggregate: {
            args: Prisma.RenderJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRenderJob>
          }
          groupBy: {
            args: Prisma.RenderJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<RenderJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.RenderJobCountArgs<ExtArgs>
            result: $Utils.Optional<RenderJobCountAggregateOutputType> | number
          }
        }
      }
      CreditsLedger: {
        payload: Prisma.$CreditsLedgerPayload<ExtArgs>
        fields: Prisma.CreditsLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditsLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditsLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          findFirst: {
            args: Prisma.CreditsLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditsLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          findMany: {
            args: Prisma.CreditsLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>[]
          }
          create: {
            args: Prisma.CreditsLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          createMany: {
            args: Prisma.CreditsLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditsLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>[]
          }
          delete: {
            args: Prisma.CreditsLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          update: {
            args: Prisma.CreditsLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          deleteMany: {
            args: Prisma.CreditsLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditsLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreditsLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsLedgerPayload>
          }
          aggregate: {
            args: Prisma.CreditsLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditsLedger>
          }
          groupBy: {
            args: Prisma.CreditsLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditsLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditsLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<CreditsLedgerCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Usage: {
        payload: Prisma.$UsagePayload<ExtArgs>
        fields: Prisma.UsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          findFirst: {
            args: Prisma.UsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          findMany: {
            args: Prisma.UsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>[]
          }
          create: {
            args: Prisma.UsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          createMany: {
            args: Prisma.UsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>[]
          }
          delete: {
            args: Prisma.UsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          update: {
            args: Prisma.UsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          deleteMany: {
            args: Prisma.UsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsagePayload>
          }
          aggregate: {
            args: Prisma.UsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsage>
          }
          groupBy: {
            args: Prisma.UsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageCountArgs<ExtArgs>
            result: $Utils.Optional<UsageCountAggregateOutputType> | number
          }
        }
      }
      EventAnalytics: {
        payload: Prisma.$EventAnalyticsPayload<ExtArgs>
        fields: Prisma.EventAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.EventAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          findMany: {
            args: Prisma.EventAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>[]
          }
          create: {
            args: Prisma.EventAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          createMany: {
            args: Prisma.EventAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.EventAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          update: {
            args: Prisma.EventAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.EventAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.EventAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventAnalytics>
          }
          groupBy: {
            args: Prisma.EventAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<EventAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      HelpCenterConversation: {
        payload: Prisma.$HelpCenterConversationPayload<ExtArgs>
        fields: Prisma.HelpCenterConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpCenterConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpCenterConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          findFirst: {
            args: Prisma.HelpCenterConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpCenterConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          findMany: {
            args: Prisma.HelpCenterConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>[]
          }
          create: {
            args: Prisma.HelpCenterConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          createMany: {
            args: Prisma.HelpCenterConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpCenterConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>[]
          }
          delete: {
            args: Prisma.HelpCenterConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          update: {
            args: Prisma.HelpCenterConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          deleteMany: {
            args: Prisma.HelpCenterConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpCenterConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpCenterConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterConversationPayload>
          }
          aggregate: {
            args: Prisma.HelpCenterConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCenterConversation>
          }
          groupBy: {
            args: Prisma.HelpCenterConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCenterConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCenterConversationCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCenterConversationCountAggregateOutputType> | number
          }
        }
      }
      HelpCenterMessage: {
        payload: Prisma.$HelpCenterMessagePayload<ExtArgs>
        fields: Prisma.HelpCenterMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpCenterMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpCenterMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          findFirst: {
            args: Prisma.HelpCenterMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpCenterMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          findMany: {
            args: Prisma.HelpCenterMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>[]
          }
          create: {
            args: Prisma.HelpCenterMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          createMany: {
            args: Prisma.HelpCenterMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpCenterMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>[]
          }
          delete: {
            args: Prisma.HelpCenterMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          update: {
            args: Prisma.HelpCenterMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          deleteMany: {
            args: Prisma.HelpCenterMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpCenterMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpCenterMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCenterMessagePayload>
          }
          aggregate: {
            args: Prisma.HelpCenterMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCenterMessage>
          }
          groupBy: {
            args: Prisma.HelpCenterMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCenterMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCenterMessageCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCenterMessageCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    photos: number
    wardrobeItems: number
    outfits: number
    renderJobs: number
    creditsLedger: number
    subscriptions: number
    purchases: number
    usageRecords: number
    eventsAnalytics: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | UserCountOutputTypeCountPhotosArgs
    wardrobeItems?: boolean | UserCountOutputTypeCountWardrobeItemsArgs
    outfits?: boolean | UserCountOutputTypeCountOutfitsArgs
    renderJobs?: boolean | UserCountOutputTypeCountRenderJobsArgs
    creditsLedger?: boolean | UserCountOutputTypeCountCreditsLedgerArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    usageRecords?: boolean | UserCountOutputTypeCountUsageRecordsArgs
    eventsAnalytics?: boolean | UserCountOutputTypeCountEventsAnalyticsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWardrobeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardrobeItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRenderJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RenderJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditsLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAnalyticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type WardrobeItemCountOutputType
   */

  export type WardrobeItemCountOutputType = {
    outfitItems: number
  }

  export type WardrobeItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfitItems?: boolean | WardrobeItemCountOutputTypeCountOutfitItemsArgs
  }

  // Custom InputTypes
  /**
   * WardrobeItemCountOutputType without action
   */
  export type WardrobeItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItemCountOutputType
     */
    select?: WardrobeItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardrobeItemCountOutputType without action
   */
  export type WardrobeItemCountOutputTypeCountOutfitItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitItemWhereInput
  }


  /**
   * Count Type OutfitCountOutputType
   */

  export type OutfitCountOutputType = {
    outfitItems: number
    renderJobs: number
  }

  export type OutfitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfitItems?: boolean | OutfitCountOutputTypeCountOutfitItemsArgs
    renderJobs?: boolean | OutfitCountOutputTypeCountRenderJobsArgs
  }

  // Custom InputTypes
  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitCountOutputType
     */
    select?: OutfitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeCountOutfitItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitItemWhereInput
  }

  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeCountRenderJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RenderJobWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    purchases: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | SubscriptionCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type HelpCenterConversationCountOutputType
   */

  export type HelpCenterConversationCountOutputType = {
    messages: number
  }

  export type HelpCenterConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | HelpCenterConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * HelpCenterConversationCountOutputType without action
   */
  export type HelpCenterConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversationCountOutputType
     */
    select?: HelpCenterConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpCenterConversationCountOutputType without action
   */
  export type HelpCenterConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCenterMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    age: number | null
    heightCm: number | null
  }

  export type UserSumAggregateOutputType = {
    age: number | null
    heightCm: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    avatarBaseImageUrl: string | null
    onboardingStatus: string | null
    sex: string | null
    age: number | null
    heightCm: number | null
    emailVerificationCode: string | null
    emailVerificationExpires: Date | null
    emailVerifiedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    avatarBaseImageUrl: string | null
    onboardingStatus: string | null
    sex: string | null
    age: number | null
    heightCm: number | null
    emailVerificationCode: string | null
    emailVerificationExpires: Date | null
    emailVerifiedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    avatarBaseImageUrl: number
    onboardingStatus: number
    sex: number
    age: number
    heightCm: number
    emailVerificationCode: number
    emailVerificationExpires: number
    emailVerifiedAt: number
    passwordResetToken: number
    passwordResetExpires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    age?: true
    heightCm?: true
  }

  export type UserSumAggregateInputType = {
    age?: true
    heightCm?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    avatarBaseImageUrl?: true
    onboardingStatus?: true
    sex?: true
    age?: true
    heightCm?: true
    emailVerificationCode?: true
    emailVerificationExpires?: true
    emailVerifiedAt?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    avatarBaseImageUrl?: true
    onboardingStatus?: true
    sex?: true
    age?: true
    heightCm?: true
    emailVerificationCode?: true
    emailVerificationExpires?: true
    emailVerifiedAt?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    avatarBaseImageUrl?: true
    onboardingStatus?: true
    sex?: true
    age?: true
    heightCm?: true
    emailVerificationCode?: true
    emailVerificationExpires?: true
    emailVerifiedAt?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    avatarBaseImageUrl: string | null
    onboardingStatus: string
    sex: string | null
    age: number | null
    heightCm: number | null
    emailVerificationCode: string | null
    emailVerificationExpires: Date | null
    emailVerifiedAt: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    avatarBaseImageUrl?: boolean
    onboardingStatus?: boolean
    sex?: boolean
    age?: boolean
    heightCm?: boolean
    emailVerificationCode?: boolean
    emailVerificationExpires?: boolean
    emailVerifiedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photos?: boolean | User$photosArgs<ExtArgs>
    wardrobeItems?: boolean | User$wardrobeItemsArgs<ExtArgs>
    outfits?: boolean | User$outfitsArgs<ExtArgs>
    renderJobs?: boolean | User$renderJobsArgs<ExtArgs>
    creditsLedger?: boolean | User$creditsLedgerArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    usageRecords?: boolean | User$usageRecordsArgs<ExtArgs>
    eventsAnalytics?: boolean | User$eventsAnalyticsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    helpCenterConversation?: boolean | User$helpCenterConversationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    avatarBaseImageUrl?: boolean
    onboardingStatus?: boolean
    sex?: boolean
    age?: boolean
    heightCm?: boolean
    emailVerificationCode?: boolean
    emailVerificationExpires?: boolean
    emailVerifiedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    avatarBaseImageUrl?: boolean
    onboardingStatus?: boolean
    sex?: boolean
    age?: boolean
    heightCm?: boolean
    emailVerificationCode?: boolean
    emailVerificationExpires?: boolean
    emailVerifiedAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | User$photosArgs<ExtArgs>
    wardrobeItems?: boolean | User$wardrobeItemsArgs<ExtArgs>
    outfits?: boolean | User$outfitsArgs<ExtArgs>
    renderJobs?: boolean | User$renderJobsArgs<ExtArgs>
    creditsLedger?: boolean | User$creditsLedgerArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    usageRecords?: boolean | User$usageRecordsArgs<ExtArgs>
    eventsAnalytics?: boolean | User$eventsAnalyticsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    helpCenterConversation?: boolean | User$helpCenterConversationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      photos: Prisma.$UserPhotoPayload<ExtArgs>[]
      wardrobeItems: Prisma.$WardrobeItemPayload<ExtArgs>[]
      outfits: Prisma.$OutfitPayload<ExtArgs>[]
      renderJobs: Prisma.$RenderJobPayload<ExtArgs>[]
      creditsLedger: Prisma.$CreditsLedgerPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      usageRecords: Prisma.$UsagePayload<ExtArgs>[]
      eventsAnalytics: Prisma.$EventAnalyticsPayload<ExtArgs>[]
      notificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      helpCenterConversation: Prisma.$HelpCenterConversationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      avatarBaseImageUrl: string | null
      onboardingStatus: string
      sex: string | null
      age: number | null
      heightCm: number | null
      emailVerificationCode: string | null
      emailVerificationExpires: Date | null
      emailVerifiedAt: Date | null
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends User$photosArgs<ExtArgs> = {}>(args?: Subset<T, User$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany"> | Null>
    wardrobeItems<T extends User$wardrobeItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$wardrobeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findMany"> | Null>
    outfits<T extends User$outfitsArgs<ExtArgs> = {}>(args?: Subset<T, User$outfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany"> | Null>
    renderJobs<T extends User$renderJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$renderJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findMany"> | Null>
    creditsLedger<T extends User$creditsLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$creditsLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    usageRecords<T extends User$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findMany"> | Null>
    eventsAnalytics<T extends User$eventsAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findMany"> | Null>
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    helpCenterConversation<T extends User$helpCenterConversationArgs<ExtArgs> = {}>(args?: Subset<T, User$helpCenterConversationArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly avatarBaseImageUrl: FieldRef<"User", 'String'>
    readonly onboardingStatus: FieldRef<"User", 'String'>
    readonly sex: FieldRef<"User", 'String'>
    readonly age: FieldRef<"User", 'Int'>
    readonly heightCm: FieldRef<"User", 'Int'>
    readonly emailVerificationCode: FieldRef<"User", 'String'>
    readonly emailVerificationExpires: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.photos
   */
  export type User$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    cursor?: UserPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * User.wardrobeItems
   */
  export type User$wardrobeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    where?: WardrobeItemWhereInput
    orderBy?: WardrobeItemOrderByWithRelationInput | WardrobeItemOrderByWithRelationInput[]
    cursor?: WardrobeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardrobeItemScalarFieldEnum | WardrobeItemScalarFieldEnum[]
  }

  /**
   * User.outfits
   */
  export type User$outfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    cursor?: OutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * User.renderJobs
   */
  export type User$renderJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    where?: RenderJobWhereInput
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    cursor?: RenderJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RenderJobScalarFieldEnum | RenderJobScalarFieldEnum[]
  }

  /**
   * User.creditsLedger
   */
  export type User$creditsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    where?: CreditsLedgerWhereInput
    orderBy?: CreditsLedgerOrderByWithRelationInput | CreditsLedgerOrderByWithRelationInput[]
    cursor?: CreditsLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditsLedgerScalarFieldEnum | CreditsLedgerScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.usageRecords
   */
  export type User$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    where?: UsageWhereInput
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    cursor?: UsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * User.eventsAnalytics
   */
  export type User$eventsAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    where?: EventAnalyticsWhereInput
    orderBy?: EventAnalyticsOrderByWithRelationInput | EventAnalyticsOrderByWithRelationInput[]
    cursor?: EventAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAnalyticsScalarFieldEnum | EventAnalyticsScalarFieldEnum[]
  }

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.helpCenterConversation
   */
  export type User$helpCenterConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    where?: HelpCenterConversationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPhoto
   */

  export type AggregateUserPhoto = {
    _count: UserPhotoCountAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  export type UserPhotoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    isPrimary: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    isPrimary: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoCountAggregateOutputType = {
    id: number
    userId: number
    imageUrl: number
    isPrimary: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPhotoMinAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    isPrimary?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoMaxAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    isPrimary?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoCountAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    isPrimary?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoto to aggregate.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhotos
    **/
    _count?: true | UserPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhotoMaxAggregateInputType
  }

  export type GetUserPhotoAggregateType<T extends UserPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhoto[P]>
      : GetScalarType<T[P], AggregateUserPhoto[P]>
  }




  export type UserPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithAggregationInput | UserPhotoOrderByWithAggregationInput[]
    by: UserPhotoScalarFieldEnum[] | UserPhotoScalarFieldEnum
    having?: UserPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhotoCountAggregateInputType | true
    _min?: UserPhotoMinAggregateInputType
    _max?: UserPhotoMaxAggregateInputType
  }

  export type UserPhotoGroupByOutputType = {
    id: string
    userId: string
    imageUrl: string
    isPrimary: boolean
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserPhotoCountAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  type GetUserPhotoGroupByPayload<T extends UserPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
        }
      >
    >


  export type UserPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    isPrimary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhoto"]>

  export type UserPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    isPrimary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhoto"]>

  export type UserPhotoSelectScalar = {
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    isPrimary?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhoto"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      imageUrl: string
      isPrimary: boolean
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPhoto"]>
    composites: {}
  }

  type UserPhotoGetPayload<S extends boolean | null | undefined | UserPhotoDefaultArgs> = $Result.GetResult<Prisma.$UserPhotoPayload, S>

  type UserPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPhotoCountAggregateInputType | true
    }

  export interface UserPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhoto'], meta: { name: 'UserPhoto' } }
    /**
     * Find zero or one UserPhoto that matches the filter.
     * @param {UserPhotoFindUniqueArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhotoFindUniqueArgs>(args: SelectSubset<T, UserPhotoFindUniqueArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserPhoto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserPhotoFindUniqueOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhotoFindFirstArgs>(args?: SelectSubset<T, UserPhotoFindFirstArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany()
     * 
     * // Get first 10 UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhotoWithIdOnly = await prisma.userPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhotoFindManyArgs>(args?: SelectSubset<T, UserPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserPhoto.
     * @param {UserPhotoCreateArgs} args - Arguments to create a UserPhoto.
     * @example
     * // Create one UserPhoto
     * const UserPhoto = await prisma.userPhoto.create({
     *   data: {
     *     // ... data to create a UserPhoto
     *   }
     * })
     * 
     */
    create<T extends UserPhotoCreateArgs>(args: SelectSubset<T, UserPhotoCreateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserPhotos.
     * @param {UserPhotoCreateManyArgs} args - Arguments to create many UserPhotos.
     * @example
     * // Create many UserPhotos
     * const userPhoto = await prisma.userPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhotoCreateManyArgs>(args?: SelectSubset<T, UserPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPhotos and returns the data saved in the database.
     * @param {UserPhotoCreateManyAndReturnArgs} args - Arguments to create many UserPhotos.
     * @example
     * // Create many UserPhotos
     * const userPhoto = await prisma.userPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPhotos and only return the `id`
     * const userPhotoWithIdOnly = await prisma.userPhoto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserPhoto.
     * @param {UserPhotoDeleteArgs} args - Arguments to delete one UserPhoto.
     * @example
     * // Delete one UserPhoto
     * const UserPhoto = await prisma.userPhoto.delete({
     *   where: {
     *     // ... filter to delete one UserPhoto
     *   }
     * })
     * 
     */
    delete<T extends UserPhotoDeleteArgs>(args: SelectSubset<T, UserPhotoDeleteArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserPhoto.
     * @param {UserPhotoUpdateArgs} args - Arguments to update one UserPhoto.
     * @example
     * // Update one UserPhoto
     * const userPhoto = await prisma.userPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhotoUpdateArgs>(args: SelectSubset<T, UserPhotoUpdateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserPhotos.
     * @param {UserPhotoDeleteManyArgs} args - Arguments to filter UserPhotos to delete.
     * @example
     * // Delete a few UserPhotos
     * const { count } = await prisma.userPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhotoDeleteManyArgs>(args?: SelectSubset<T, UserPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhotos
     * const userPhoto = await prisma.userPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhotoUpdateManyArgs>(args: SelectSubset<T, UserPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPhoto.
     * @param {UserPhotoUpsertArgs} args - Arguments to update or create a UserPhoto.
     * @example
     * // Update or create a UserPhoto
     * const userPhoto = await prisma.userPhoto.upsert({
     *   create: {
     *     // ... data to create a UserPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhoto we want to update
     *   }
     * })
     */
    upsert<T extends UserPhotoUpsertArgs>(args: SelectSubset<T, UserPhotoUpsertArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoCountArgs} args - Arguments to filter UserPhotos to count.
     * @example
     * // Count the number of UserPhotos
     * const count = await prisma.userPhoto.count({
     *   where: {
     *     // ... the filter for the UserPhotos we want to count
     *   }
     * })
    **/
    count<T extends UserPhotoCountArgs>(
      args?: Subset<T, UserPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhotoAggregateArgs>(args: Subset<T, UserPhotoAggregateArgs>): Prisma.PrismaPromise<GetUserPhotoAggregateType<T>>

    /**
     * Group by UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhotoGroupByArgs['orderBy'] }
        : { orderBy?: UserPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhoto model
   */
  readonly fields: UserPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhoto model
   */ 
  interface UserPhotoFieldRefs {
    readonly id: FieldRef<"UserPhoto", 'String'>
    readonly userId: FieldRef<"UserPhoto", 'String'>
    readonly imageUrl: FieldRef<"UserPhoto", 'String'>
    readonly isPrimary: FieldRef<"UserPhoto", 'Boolean'>
    readonly metadata: FieldRef<"UserPhoto", 'String'>
    readonly createdAt: FieldRef<"UserPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhoto findUnique
   */
  export type UserPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findUniqueOrThrow
   */
  export type UserPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findFirst
   */
  export type UserPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findFirstOrThrow
   */
  export type UserPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findMany
   */
  export type UserPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhotos to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto create
   */
  export type UserPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhoto.
     */
    data: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
  }

  /**
   * UserPhoto createMany
   */
  export type UserPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhotos.
     */
    data: UserPhotoCreateManyInput | UserPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhoto createManyAndReturn
   */
  export type UserPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserPhotos.
     */
    data: UserPhotoCreateManyInput | UserPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhoto update
   */
  export type UserPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhoto.
     */
    data: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
    /**
     * Choose, which UserPhoto to update.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto updateMany
   */
  export type UserPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhotos.
     */
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyInput>
    /**
     * Filter which UserPhotos to update
     */
    where?: UserPhotoWhereInput
  }

  /**
   * UserPhoto upsert
   */
  export type UserPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhoto to update in case it exists.
     */
    where: UserPhotoWhereUniqueInput
    /**
     * In case the UserPhoto found by the `where` argument doesn't exist, create a new UserPhoto with this data.
     */
    create: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
    /**
     * In case the UserPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
  }

  /**
   * UserPhoto delete
   */
  export type UserPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter which UserPhoto to delete.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto deleteMany
   */
  export type UserPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhotos to delete
     */
    where?: UserPhotoWhereInput
  }

  /**
   * UserPhoto without action
   */
  export type UserPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
  }


  /**
   * Model WardrobeItem
   */

  export type AggregateWardrobeItem = {
    _count: WardrobeItemCountAggregateOutputType | null
    _min: WardrobeItemMinAggregateOutputType | null
    _max: WardrobeItemMaxAggregateOutputType | null
  }

  export type WardrobeItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    cutoutImageUrl: string | null
    cutoutStatus: string | null
    cutoutError: string | null
    category: string | null
    colorFamily: string | null
    colorHex: string | null
    styleTags: string | null
    seasonTags: string | null
    fitTag: string | null
    extraTags: string | null
    confidence: string | null
    rawAiJson: string | null
    userNotes: string | null
    productType: string | null
    color: string | null
    tags: string | null
    brand: string | null
    size: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardrobeItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    cutoutImageUrl: string | null
    cutoutStatus: string | null
    cutoutError: string | null
    category: string | null
    colorFamily: string | null
    colorHex: string | null
    styleTags: string | null
    seasonTags: string | null
    fitTag: string | null
    extraTags: string | null
    confidence: string | null
    rawAiJson: string | null
    userNotes: string | null
    productType: string | null
    color: string | null
    tags: string | null
    brand: string | null
    size: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardrobeItemCountAggregateOutputType = {
    id: number
    userId: number
    imageUrl: number
    cutoutImageUrl: number
    cutoutStatus: number
    cutoutError: number
    category: number
    colorFamily: number
    colorHex: number
    styleTags: number
    seasonTags: number
    fitTag: number
    extraTags: number
    confidence: number
    rawAiJson: number
    userNotes: number
    productType: number
    color: number
    tags: number
    brand: number
    size: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WardrobeItemMinAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    cutoutImageUrl?: true
    cutoutStatus?: true
    cutoutError?: true
    category?: true
    colorFamily?: true
    colorHex?: true
    styleTags?: true
    seasonTags?: true
    fitTag?: true
    extraTags?: true
    confidence?: true
    rawAiJson?: true
    userNotes?: true
    productType?: true
    color?: true
    tags?: true
    brand?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardrobeItemMaxAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    cutoutImageUrl?: true
    cutoutStatus?: true
    cutoutError?: true
    category?: true
    colorFamily?: true
    colorHex?: true
    styleTags?: true
    seasonTags?: true
    fitTag?: true
    extraTags?: true
    confidence?: true
    rawAiJson?: true
    userNotes?: true
    productType?: true
    color?: true
    tags?: true
    brand?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardrobeItemCountAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    cutoutImageUrl?: true
    cutoutStatus?: true
    cutoutError?: true
    category?: true
    colorFamily?: true
    colorHex?: true
    styleTags?: true
    seasonTags?: true
    fitTag?: true
    extraTags?: true
    confidence?: true
    rawAiJson?: true
    userNotes?: true
    productType?: true
    color?: true
    tags?: true
    brand?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WardrobeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardrobeItem to aggregate.
     */
    where?: WardrobeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardrobeItems to fetch.
     */
    orderBy?: WardrobeItemOrderByWithRelationInput | WardrobeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardrobeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardrobeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardrobeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WardrobeItems
    **/
    _count?: true | WardrobeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardrobeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardrobeItemMaxAggregateInputType
  }

  export type GetWardrobeItemAggregateType<T extends WardrobeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWardrobeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWardrobeItem[P]>
      : GetScalarType<T[P], AggregateWardrobeItem[P]>
  }




  export type WardrobeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardrobeItemWhereInput
    orderBy?: WardrobeItemOrderByWithAggregationInput | WardrobeItemOrderByWithAggregationInput[]
    by: WardrobeItemScalarFieldEnum[] | WardrobeItemScalarFieldEnum
    having?: WardrobeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardrobeItemCountAggregateInputType | true
    _min?: WardrobeItemMinAggregateInputType
    _max?: WardrobeItemMaxAggregateInputType
  }

  export type WardrobeItemGroupByOutputType = {
    id: string
    userId: string
    imageUrl: string
    cutoutImageUrl: string | null
    cutoutStatus: string
    cutoutError: string | null
    category: string
    colorFamily: string
    colorHex: string | null
    styleTags: string
    seasonTags: string
    fitTag: string
    extraTags: string | null
    confidence: string
    rawAiJson: string | null
    userNotes: string | null
    productType: string | null
    color: string | null
    tags: string | null
    brand: string | null
    size: string | null
    createdAt: Date
    updatedAt: Date
    _count: WardrobeItemCountAggregateOutputType | null
    _min: WardrobeItemMinAggregateOutputType | null
    _max: WardrobeItemMaxAggregateOutputType | null
  }

  type GetWardrobeItemGroupByPayload<T extends WardrobeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardrobeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardrobeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardrobeItemGroupByOutputType[P]>
            : GetScalarType<T[P], WardrobeItemGroupByOutputType[P]>
        }
      >
    >


  export type WardrobeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    cutoutImageUrl?: boolean
    cutoutStatus?: boolean
    cutoutError?: boolean
    category?: boolean
    colorFamily?: boolean
    colorHex?: boolean
    styleTags?: boolean
    seasonTags?: boolean
    fitTag?: boolean
    extraTags?: boolean
    confidence?: boolean
    rawAiJson?: boolean
    userNotes?: boolean
    productType?: boolean
    color?: boolean
    tags?: boolean
    brand?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfitItems?: boolean | WardrobeItem$outfitItemsArgs<ExtArgs>
    _count?: boolean | WardrobeItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardrobeItem"]>

  export type WardrobeItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    cutoutImageUrl?: boolean
    cutoutStatus?: boolean
    cutoutError?: boolean
    category?: boolean
    colorFamily?: boolean
    colorHex?: boolean
    styleTags?: boolean
    seasonTags?: boolean
    fitTag?: boolean
    extraTags?: boolean
    confidence?: boolean
    rawAiJson?: boolean
    userNotes?: boolean
    productType?: boolean
    color?: boolean
    tags?: boolean
    brand?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardrobeItem"]>

  export type WardrobeItemSelectScalar = {
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    cutoutImageUrl?: boolean
    cutoutStatus?: boolean
    cutoutError?: boolean
    category?: boolean
    colorFamily?: boolean
    colorHex?: boolean
    styleTags?: boolean
    seasonTags?: boolean
    fitTag?: boolean
    extraTags?: boolean
    confidence?: boolean
    rawAiJson?: boolean
    userNotes?: boolean
    productType?: boolean
    color?: boolean
    tags?: boolean
    brand?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WardrobeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfitItems?: boolean | WardrobeItem$outfitItemsArgs<ExtArgs>
    _count?: boolean | WardrobeItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardrobeItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WardrobeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WardrobeItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      outfitItems: Prisma.$OutfitItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      imageUrl: string
      cutoutImageUrl: string | null
      cutoutStatus: string
      cutoutError: string | null
      category: string
      colorFamily: string
      colorHex: string | null
      styleTags: string
      seasonTags: string
      fitTag: string
      extraTags: string | null
      confidence: string
      rawAiJson: string | null
      userNotes: string | null
      productType: string | null
      color: string | null
      tags: string | null
      brand: string | null
      size: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wardrobeItem"]>
    composites: {}
  }

  type WardrobeItemGetPayload<S extends boolean | null | undefined | WardrobeItemDefaultArgs> = $Result.GetResult<Prisma.$WardrobeItemPayload, S>

  type WardrobeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardrobeItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardrobeItemCountAggregateInputType | true
    }

  export interface WardrobeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WardrobeItem'], meta: { name: 'WardrobeItem' } }
    /**
     * Find zero or one WardrobeItem that matches the filter.
     * @param {WardrobeItemFindUniqueArgs} args - Arguments to find a WardrobeItem
     * @example
     * // Get one WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardrobeItemFindUniqueArgs>(args: SelectSubset<T, WardrobeItemFindUniqueArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WardrobeItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardrobeItemFindUniqueOrThrowArgs} args - Arguments to find a WardrobeItem
     * @example
     * // Get one WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardrobeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WardrobeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WardrobeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemFindFirstArgs} args - Arguments to find a WardrobeItem
     * @example
     * // Get one WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardrobeItemFindFirstArgs>(args?: SelectSubset<T, WardrobeItemFindFirstArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WardrobeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemFindFirstOrThrowArgs} args - Arguments to find a WardrobeItem
     * @example
     * // Get one WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardrobeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WardrobeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WardrobeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WardrobeItems
     * const wardrobeItems = await prisma.wardrobeItem.findMany()
     * 
     * // Get first 10 WardrobeItems
     * const wardrobeItems = await prisma.wardrobeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardrobeItemWithIdOnly = await prisma.wardrobeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardrobeItemFindManyArgs>(args?: SelectSubset<T, WardrobeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WardrobeItem.
     * @param {WardrobeItemCreateArgs} args - Arguments to create a WardrobeItem.
     * @example
     * // Create one WardrobeItem
     * const WardrobeItem = await prisma.wardrobeItem.create({
     *   data: {
     *     // ... data to create a WardrobeItem
     *   }
     * })
     * 
     */
    create<T extends WardrobeItemCreateArgs>(args: SelectSubset<T, WardrobeItemCreateArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WardrobeItems.
     * @param {WardrobeItemCreateManyArgs} args - Arguments to create many WardrobeItems.
     * @example
     * // Create many WardrobeItems
     * const wardrobeItem = await prisma.wardrobeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardrobeItemCreateManyArgs>(args?: SelectSubset<T, WardrobeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WardrobeItems and returns the data saved in the database.
     * @param {WardrobeItemCreateManyAndReturnArgs} args - Arguments to create many WardrobeItems.
     * @example
     * // Create many WardrobeItems
     * const wardrobeItem = await prisma.wardrobeItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WardrobeItems and only return the `id`
     * const wardrobeItemWithIdOnly = await prisma.wardrobeItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardrobeItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WardrobeItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WardrobeItem.
     * @param {WardrobeItemDeleteArgs} args - Arguments to delete one WardrobeItem.
     * @example
     * // Delete one WardrobeItem
     * const WardrobeItem = await prisma.wardrobeItem.delete({
     *   where: {
     *     // ... filter to delete one WardrobeItem
     *   }
     * })
     * 
     */
    delete<T extends WardrobeItemDeleteArgs>(args: SelectSubset<T, WardrobeItemDeleteArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WardrobeItem.
     * @param {WardrobeItemUpdateArgs} args - Arguments to update one WardrobeItem.
     * @example
     * // Update one WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardrobeItemUpdateArgs>(args: SelectSubset<T, WardrobeItemUpdateArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WardrobeItems.
     * @param {WardrobeItemDeleteManyArgs} args - Arguments to filter WardrobeItems to delete.
     * @example
     * // Delete a few WardrobeItems
     * const { count } = await prisma.wardrobeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardrobeItemDeleteManyArgs>(args?: SelectSubset<T, WardrobeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WardrobeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WardrobeItems
     * const wardrobeItem = await prisma.wardrobeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardrobeItemUpdateManyArgs>(args: SelectSubset<T, WardrobeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WardrobeItem.
     * @param {WardrobeItemUpsertArgs} args - Arguments to update or create a WardrobeItem.
     * @example
     * // Update or create a WardrobeItem
     * const wardrobeItem = await prisma.wardrobeItem.upsert({
     *   create: {
     *     // ... data to create a WardrobeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WardrobeItem we want to update
     *   }
     * })
     */
    upsert<T extends WardrobeItemUpsertArgs>(args: SelectSubset<T, WardrobeItemUpsertArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WardrobeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemCountArgs} args - Arguments to filter WardrobeItems to count.
     * @example
     * // Count the number of WardrobeItems
     * const count = await prisma.wardrobeItem.count({
     *   where: {
     *     // ... the filter for the WardrobeItems we want to count
     *   }
     * })
    **/
    count<T extends WardrobeItemCountArgs>(
      args?: Subset<T, WardrobeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardrobeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WardrobeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardrobeItemAggregateArgs>(args: Subset<T, WardrobeItemAggregateArgs>): Prisma.PrismaPromise<GetWardrobeItemAggregateType<T>>

    /**
     * Group by WardrobeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardrobeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardrobeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardrobeItemGroupByArgs['orderBy'] }
        : { orderBy?: WardrobeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardrobeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardrobeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WardrobeItem model
   */
  readonly fields: WardrobeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WardrobeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardrobeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    outfitItems<T extends WardrobeItem$outfitItemsArgs<ExtArgs> = {}>(args?: Subset<T, WardrobeItem$outfitItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WardrobeItem model
   */ 
  interface WardrobeItemFieldRefs {
    readonly id: FieldRef<"WardrobeItem", 'String'>
    readonly userId: FieldRef<"WardrobeItem", 'String'>
    readonly imageUrl: FieldRef<"WardrobeItem", 'String'>
    readonly cutoutImageUrl: FieldRef<"WardrobeItem", 'String'>
    readonly cutoutStatus: FieldRef<"WardrobeItem", 'String'>
    readonly cutoutError: FieldRef<"WardrobeItem", 'String'>
    readonly category: FieldRef<"WardrobeItem", 'String'>
    readonly colorFamily: FieldRef<"WardrobeItem", 'String'>
    readonly colorHex: FieldRef<"WardrobeItem", 'String'>
    readonly styleTags: FieldRef<"WardrobeItem", 'String'>
    readonly seasonTags: FieldRef<"WardrobeItem", 'String'>
    readonly fitTag: FieldRef<"WardrobeItem", 'String'>
    readonly extraTags: FieldRef<"WardrobeItem", 'String'>
    readonly confidence: FieldRef<"WardrobeItem", 'String'>
    readonly rawAiJson: FieldRef<"WardrobeItem", 'String'>
    readonly userNotes: FieldRef<"WardrobeItem", 'String'>
    readonly productType: FieldRef<"WardrobeItem", 'String'>
    readonly color: FieldRef<"WardrobeItem", 'String'>
    readonly tags: FieldRef<"WardrobeItem", 'String'>
    readonly brand: FieldRef<"WardrobeItem", 'String'>
    readonly size: FieldRef<"WardrobeItem", 'String'>
    readonly createdAt: FieldRef<"WardrobeItem", 'DateTime'>
    readonly updatedAt: FieldRef<"WardrobeItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WardrobeItem findUnique
   */
  export type WardrobeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter, which WardrobeItem to fetch.
     */
    where: WardrobeItemWhereUniqueInput
  }

  /**
   * WardrobeItem findUniqueOrThrow
   */
  export type WardrobeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter, which WardrobeItem to fetch.
     */
    where: WardrobeItemWhereUniqueInput
  }

  /**
   * WardrobeItem findFirst
   */
  export type WardrobeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter, which WardrobeItem to fetch.
     */
    where?: WardrobeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardrobeItems to fetch.
     */
    orderBy?: WardrobeItemOrderByWithRelationInput | WardrobeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardrobeItems.
     */
    cursor?: WardrobeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardrobeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardrobeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardrobeItems.
     */
    distinct?: WardrobeItemScalarFieldEnum | WardrobeItemScalarFieldEnum[]
  }

  /**
   * WardrobeItem findFirstOrThrow
   */
  export type WardrobeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter, which WardrobeItem to fetch.
     */
    where?: WardrobeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardrobeItems to fetch.
     */
    orderBy?: WardrobeItemOrderByWithRelationInput | WardrobeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardrobeItems.
     */
    cursor?: WardrobeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardrobeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardrobeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardrobeItems.
     */
    distinct?: WardrobeItemScalarFieldEnum | WardrobeItemScalarFieldEnum[]
  }

  /**
   * WardrobeItem findMany
   */
  export type WardrobeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter, which WardrobeItems to fetch.
     */
    where?: WardrobeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardrobeItems to fetch.
     */
    orderBy?: WardrobeItemOrderByWithRelationInput | WardrobeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WardrobeItems.
     */
    cursor?: WardrobeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardrobeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardrobeItems.
     */
    skip?: number
    distinct?: WardrobeItemScalarFieldEnum | WardrobeItemScalarFieldEnum[]
  }

  /**
   * WardrobeItem create
   */
  export type WardrobeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WardrobeItem.
     */
    data: XOR<WardrobeItemCreateInput, WardrobeItemUncheckedCreateInput>
  }

  /**
   * WardrobeItem createMany
   */
  export type WardrobeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WardrobeItems.
     */
    data: WardrobeItemCreateManyInput | WardrobeItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardrobeItem createManyAndReturn
   */
  export type WardrobeItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WardrobeItems.
     */
    data: WardrobeItemCreateManyInput | WardrobeItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WardrobeItem update
   */
  export type WardrobeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WardrobeItem.
     */
    data: XOR<WardrobeItemUpdateInput, WardrobeItemUncheckedUpdateInput>
    /**
     * Choose, which WardrobeItem to update.
     */
    where: WardrobeItemWhereUniqueInput
  }

  /**
   * WardrobeItem updateMany
   */
  export type WardrobeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WardrobeItems.
     */
    data: XOR<WardrobeItemUpdateManyMutationInput, WardrobeItemUncheckedUpdateManyInput>
    /**
     * Filter which WardrobeItems to update
     */
    where?: WardrobeItemWhereInput
  }

  /**
   * WardrobeItem upsert
   */
  export type WardrobeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WardrobeItem to update in case it exists.
     */
    where: WardrobeItemWhereUniqueInput
    /**
     * In case the WardrobeItem found by the `where` argument doesn't exist, create a new WardrobeItem with this data.
     */
    create: XOR<WardrobeItemCreateInput, WardrobeItemUncheckedCreateInput>
    /**
     * In case the WardrobeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardrobeItemUpdateInput, WardrobeItemUncheckedUpdateInput>
  }

  /**
   * WardrobeItem delete
   */
  export type WardrobeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
    /**
     * Filter which WardrobeItem to delete.
     */
    where: WardrobeItemWhereUniqueInput
  }

  /**
   * WardrobeItem deleteMany
   */
  export type WardrobeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardrobeItems to delete
     */
    where?: WardrobeItemWhereInput
  }

  /**
   * WardrobeItem.outfitItems
   */
  export type WardrobeItem$outfitItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    where?: OutfitItemWhereInput
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    cursor?: OutfitItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitItemScalarFieldEnum | OutfitItemScalarFieldEnum[]
  }

  /**
   * WardrobeItem without action
   */
  export type WardrobeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardrobeItem
     */
    select?: WardrobeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardrobeItemInclude<ExtArgs> | null
  }


  /**
   * Model Outfit
   */

  export type AggregateOutfit = {
    _count: OutfitCountAggregateOutputType | null
    _avg: OutfitAvgAggregateOutputType | null
    _sum: OutfitSumAggregateOutputType | null
    _min: OutfitMinAggregateOutputType | null
    _max: OutfitMaxAggregateOutputType | null
  }

  export type OutfitAvgAggregateOutputType = {
    dayIndex: number | null
  }

  export type OutfitSumAggregateOutputType = {
    dayIndex: number | null
  }

  export type OutfitMinAggregateOutputType = {
    id: string | null
    userId: string | null
    weekStartDate: Date | null
    dayIndex: number | null
    status: string | null
    imageUrl: string | null
    promptVersion: string | null
    weather: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutfitMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    weekStartDate: Date | null
    dayIndex: number | null
    status: string | null
    imageUrl: string | null
    promptVersion: string | null
    weather: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutfitCountAggregateOutputType = {
    id: number
    userId: number
    weekStartDate: number
    dayIndex: number
    status: number
    imageUrl: number
    promptVersion: number
    weather: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutfitAvgAggregateInputType = {
    dayIndex?: true
  }

  export type OutfitSumAggregateInputType = {
    dayIndex?: true
  }

  export type OutfitMinAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    dayIndex?: true
    status?: true
    imageUrl?: true
    promptVersion?: true
    weather?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutfitMaxAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    dayIndex?: true
    status?: true
    imageUrl?: true
    promptVersion?: true
    weather?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutfitCountAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    dayIndex?: true
    status?: true
    imageUrl?: true
    promptVersion?: true
    weather?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutfitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outfit to aggregate.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outfits
    **/
    _count?: true | OutfitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutfitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutfitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutfitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutfitMaxAggregateInputType
  }

  export type GetOutfitAggregateType<T extends OutfitAggregateArgs> = {
        [P in keyof T & keyof AggregateOutfit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutfit[P]>
      : GetScalarType<T[P], AggregateOutfit[P]>
  }




  export type OutfitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithAggregationInput | OutfitOrderByWithAggregationInput[]
    by: OutfitScalarFieldEnum[] | OutfitScalarFieldEnum
    having?: OutfitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutfitCountAggregateInputType | true
    _avg?: OutfitAvgAggregateInputType
    _sum?: OutfitSumAggregateInputType
    _min?: OutfitMinAggregateInputType
    _max?: OutfitMaxAggregateInputType
  }

  export type OutfitGroupByOutputType = {
    id: string
    userId: string
    weekStartDate: Date
    dayIndex: number
    status: string
    imageUrl: string | null
    promptVersion: string | null
    weather: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: OutfitCountAggregateOutputType | null
    _avg: OutfitAvgAggregateOutputType | null
    _sum: OutfitSumAggregateOutputType | null
    _min: OutfitMinAggregateOutputType | null
    _max: OutfitMaxAggregateOutputType | null
  }

  type GetOutfitGroupByPayload<T extends OutfitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutfitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutfitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutfitGroupByOutputType[P]>
            : GetScalarType<T[P], OutfitGroupByOutputType[P]>
        }
      >
    >


  export type OutfitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    dayIndex?: boolean
    status?: boolean
    imageUrl?: boolean
    promptVersion?: boolean
    weather?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfitItems?: boolean | Outfit$outfitItemsArgs<ExtArgs>
    renderJobs?: boolean | Outfit$renderJobsArgs<ExtArgs>
    _count?: boolean | OutfitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfit"]>

  export type OutfitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    dayIndex?: boolean
    status?: boolean
    imageUrl?: boolean
    promptVersion?: boolean
    weather?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfit"]>

  export type OutfitSelectScalar = {
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    dayIndex?: boolean
    status?: boolean
    imageUrl?: boolean
    promptVersion?: boolean
    weather?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutfitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfitItems?: boolean | Outfit$outfitItemsArgs<ExtArgs>
    renderJobs?: boolean | Outfit$renderJobsArgs<ExtArgs>
    _count?: boolean | OutfitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutfitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OutfitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outfit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      outfitItems: Prisma.$OutfitItemPayload<ExtArgs>[]
      renderJobs: Prisma.$RenderJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      weekStartDate: Date
      dayIndex: number
      status: string
      imageUrl: string | null
      promptVersion: string | null
      weather: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outfit"]>
    composites: {}
  }

  type OutfitGetPayload<S extends boolean | null | undefined | OutfitDefaultArgs> = $Result.GetResult<Prisma.$OutfitPayload, S>

  type OutfitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutfitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutfitCountAggregateInputType | true
    }

  export interface OutfitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outfit'], meta: { name: 'Outfit' } }
    /**
     * Find zero or one Outfit that matches the filter.
     * @param {OutfitFindUniqueArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutfitFindUniqueArgs>(args: SelectSubset<T, OutfitFindUniqueArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Outfit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutfitFindUniqueOrThrowArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutfitFindUniqueOrThrowArgs>(args: SelectSubset<T, OutfitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Outfit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindFirstArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutfitFindFirstArgs>(args?: SelectSubset<T, OutfitFindFirstArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Outfit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindFirstOrThrowArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutfitFindFirstOrThrowArgs>(args?: SelectSubset<T, OutfitFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Outfits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outfits
     * const outfits = await prisma.outfit.findMany()
     * 
     * // Get first 10 Outfits
     * const outfits = await prisma.outfit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outfitWithIdOnly = await prisma.outfit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutfitFindManyArgs>(args?: SelectSubset<T, OutfitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Outfit.
     * @param {OutfitCreateArgs} args - Arguments to create a Outfit.
     * @example
     * // Create one Outfit
     * const Outfit = await prisma.outfit.create({
     *   data: {
     *     // ... data to create a Outfit
     *   }
     * })
     * 
     */
    create<T extends OutfitCreateArgs>(args: SelectSubset<T, OutfitCreateArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Outfits.
     * @param {OutfitCreateManyArgs} args - Arguments to create many Outfits.
     * @example
     * // Create many Outfits
     * const outfit = await prisma.outfit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutfitCreateManyArgs>(args?: SelectSubset<T, OutfitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outfits and returns the data saved in the database.
     * @param {OutfitCreateManyAndReturnArgs} args - Arguments to create many Outfits.
     * @example
     * // Create many Outfits
     * const outfit = await prisma.outfit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outfits and only return the `id`
     * const outfitWithIdOnly = await prisma.outfit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutfitCreateManyAndReturnArgs>(args?: SelectSubset<T, OutfitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Outfit.
     * @param {OutfitDeleteArgs} args - Arguments to delete one Outfit.
     * @example
     * // Delete one Outfit
     * const Outfit = await prisma.outfit.delete({
     *   where: {
     *     // ... filter to delete one Outfit
     *   }
     * })
     * 
     */
    delete<T extends OutfitDeleteArgs>(args: SelectSubset<T, OutfitDeleteArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Outfit.
     * @param {OutfitUpdateArgs} args - Arguments to update one Outfit.
     * @example
     * // Update one Outfit
     * const outfit = await prisma.outfit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutfitUpdateArgs>(args: SelectSubset<T, OutfitUpdateArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Outfits.
     * @param {OutfitDeleteManyArgs} args - Arguments to filter Outfits to delete.
     * @example
     * // Delete a few Outfits
     * const { count } = await prisma.outfit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutfitDeleteManyArgs>(args?: SelectSubset<T, OutfitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outfits
     * const outfit = await prisma.outfit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutfitUpdateManyArgs>(args: SelectSubset<T, OutfitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Outfit.
     * @param {OutfitUpsertArgs} args - Arguments to update or create a Outfit.
     * @example
     * // Update or create a Outfit
     * const outfit = await prisma.outfit.upsert({
     *   create: {
     *     // ... data to create a Outfit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outfit we want to update
     *   }
     * })
     */
    upsert<T extends OutfitUpsertArgs>(args: SelectSubset<T, OutfitUpsertArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Outfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitCountArgs} args - Arguments to filter Outfits to count.
     * @example
     * // Count the number of Outfits
     * const count = await prisma.outfit.count({
     *   where: {
     *     // ... the filter for the Outfits we want to count
     *   }
     * })
    **/
    count<T extends OutfitCountArgs>(
      args?: Subset<T, OutfitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutfitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutfitAggregateArgs>(args: Subset<T, OutfitAggregateArgs>): Prisma.PrismaPromise<GetOutfitAggregateType<T>>

    /**
     * Group by Outfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutfitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutfitGroupByArgs['orderBy'] }
        : { orderBy?: OutfitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutfitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutfitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outfit model
   */
  readonly fields: OutfitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outfit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutfitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    outfitItems<T extends Outfit$outfitItemsArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$outfitItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findMany"> | Null>
    renderJobs<T extends Outfit$renderJobsArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$renderJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outfit model
   */ 
  interface OutfitFieldRefs {
    readonly id: FieldRef<"Outfit", 'String'>
    readonly userId: FieldRef<"Outfit", 'String'>
    readonly weekStartDate: FieldRef<"Outfit", 'DateTime'>
    readonly dayIndex: FieldRef<"Outfit", 'Int'>
    readonly status: FieldRef<"Outfit", 'String'>
    readonly imageUrl: FieldRef<"Outfit", 'String'>
    readonly promptVersion: FieldRef<"Outfit", 'String'>
    readonly weather: FieldRef<"Outfit", 'String'>
    readonly category: FieldRef<"Outfit", 'String'>
    readonly createdAt: FieldRef<"Outfit", 'DateTime'>
    readonly updatedAt: FieldRef<"Outfit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Outfit findUnique
   */
  export type OutfitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit findUniqueOrThrow
   */
  export type OutfitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit findFirst
   */
  export type OutfitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outfits.
     */
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit findFirstOrThrow
   */
  export type OutfitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outfits.
     */
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit findMany
   */
  export type OutfitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfits to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit create
   */
  export type OutfitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The data needed to create a Outfit.
     */
    data: XOR<OutfitCreateInput, OutfitUncheckedCreateInput>
  }

  /**
   * Outfit createMany
   */
  export type OutfitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outfits.
     */
    data: OutfitCreateManyInput | OutfitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outfit createManyAndReturn
   */
  export type OutfitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Outfits.
     */
    data: OutfitCreateManyInput | OutfitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outfit update
   */
  export type OutfitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The data needed to update a Outfit.
     */
    data: XOR<OutfitUpdateInput, OutfitUncheckedUpdateInput>
    /**
     * Choose, which Outfit to update.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit updateMany
   */
  export type OutfitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outfits.
     */
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyInput>
    /**
     * Filter which Outfits to update
     */
    where?: OutfitWhereInput
  }

  /**
   * Outfit upsert
   */
  export type OutfitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The filter to search for the Outfit to update in case it exists.
     */
    where: OutfitWhereUniqueInput
    /**
     * In case the Outfit found by the `where` argument doesn't exist, create a new Outfit with this data.
     */
    create: XOR<OutfitCreateInput, OutfitUncheckedCreateInput>
    /**
     * In case the Outfit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutfitUpdateInput, OutfitUncheckedUpdateInput>
  }

  /**
   * Outfit delete
   */
  export type OutfitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter which Outfit to delete.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit deleteMany
   */
  export type OutfitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outfits to delete
     */
    where?: OutfitWhereInput
  }

  /**
   * Outfit.outfitItems
   */
  export type Outfit$outfitItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    where?: OutfitItemWhereInput
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    cursor?: OutfitItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitItemScalarFieldEnum | OutfitItemScalarFieldEnum[]
  }

  /**
   * Outfit.renderJobs
   */
  export type Outfit$renderJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    where?: RenderJobWhereInput
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    cursor?: RenderJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RenderJobScalarFieldEnum | RenderJobScalarFieldEnum[]
  }

  /**
   * Outfit without action
   */
  export type OutfitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
  }


  /**
   * Model OutfitItem
   */

  export type AggregateOutfitItem = {
    _count: OutfitItemCountAggregateOutputType | null
    _min: OutfitItemMinAggregateOutputType | null
    _max: OutfitItemMaxAggregateOutputType | null
  }

  export type OutfitItemMinAggregateOutputType = {
    outfitId: string | null
    wardrobeItemId: string | null
  }

  export type OutfitItemMaxAggregateOutputType = {
    outfitId: string | null
    wardrobeItemId: string | null
  }

  export type OutfitItemCountAggregateOutputType = {
    outfitId: number
    wardrobeItemId: number
    _all: number
  }


  export type OutfitItemMinAggregateInputType = {
    outfitId?: true
    wardrobeItemId?: true
  }

  export type OutfitItemMaxAggregateInputType = {
    outfitId?: true
    wardrobeItemId?: true
  }

  export type OutfitItemCountAggregateInputType = {
    outfitId?: true
    wardrobeItemId?: true
    _all?: true
  }

  export type OutfitItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutfitItem to aggregate.
     */
    where?: OutfitItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitItems to fetch.
     */
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutfitItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutfitItems
    **/
    _count?: true | OutfitItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutfitItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutfitItemMaxAggregateInputType
  }

  export type GetOutfitItemAggregateType<T extends OutfitItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOutfitItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutfitItem[P]>
      : GetScalarType<T[P], AggregateOutfitItem[P]>
  }




  export type OutfitItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitItemWhereInput
    orderBy?: OutfitItemOrderByWithAggregationInput | OutfitItemOrderByWithAggregationInput[]
    by: OutfitItemScalarFieldEnum[] | OutfitItemScalarFieldEnum
    having?: OutfitItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutfitItemCountAggregateInputType | true
    _min?: OutfitItemMinAggregateInputType
    _max?: OutfitItemMaxAggregateInputType
  }

  export type OutfitItemGroupByOutputType = {
    outfitId: string
    wardrobeItemId: string
    _count: OutfitItemCountAggregateOutputType | null
    _min: OutfitItemMinAggregateOutputType | null
    _max: OutfitItemMaxAggregateOutputType | null
  }

  type GetOutfitItemGroupByPayload<T extends OutfitItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutfitItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutfitItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutfitItemGroupByOutputType[P]>
            : GetScalarType<T[P], OutfitItemGroupByOutputType[P]>
        }
      >
    >


  export type OutfitItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    outfitId?: boolean
    wardrobeItemId?: boolean
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    wardrobeItem?: boolean | WardrobeItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfitItem"]>

  export type OutfitItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    outfitId?: boolean
    wardrobeItemId?: boolean
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    wardrobeItem?: boolean | WardrobeItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfitItem"]>

  export type OutfitItemSelectScalar = {
    outfitId?: boolean
    wardrobeItemId?: boolean
  }

  export type OutfitItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    wardrobeItem?: boolean | WardrobeItemDefaultArgs<ExtArgs>
  }
  export type OutfitItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    wardrobeItem?: boolean | WardrobeItemDefaultArgs<ExtArgs>
  }

  export type $OutfitItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutfitItem"
    objects: {
      outfit: Prisma.$OutfitPayload<ExtArgs>
      wardrobeItem: Prisma.$WardrobeItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      outfitId: string
      wardrobeItemId: string
    }, ExtArgs["result"]["outfitItem"]>
    composites: {}
  }

  type OutfitItemGetPayload<S extends boolean | null | undefined | OutfitItemDefaultArgs> = $Result.GetResult<Prisma.$OutfitItemPayload, S>

  type OutfitItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutfitItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutfitItemCountAggregateInputType | true
    }

  export interface OutfitItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutfitItem'], meta: { name: 'OutfitItem' } }
    /**
     * Find zero or one OutfitItem that matches the filter.
     * @param {OutfitItemFindUniqueArgs} args - Arguments to find a OutfitItem
     * @example
     * // Get one OutfitItem
     * const outfitItem = await prisma.outfitItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutfitItemFindUniqueArgs>(args: SelectSubset<T, OutfitItemFindUniqueArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutfitItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutfitItemFindUniqueOrThrowArgs} args - Arguments to find a OutfitItem
     * @example
     * // Get one OutfitItem
     * const outfitItem = await prisma.outfitItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutfitItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OutfitItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutfitItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemFindFirstArgs} args - Arguments to find a OutfitItem
     * @example
     * // Get one OutfitItem
     * const outfitItem = await prisma.outfitItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutfitItemFindFirstArgs>(args?: SelectSubset<T, OutfitItemFindFirstArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutfitItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemFindFirstOrThrowArgs} args - Arguments to find a OutfitItem
     * @example
     * // Get one OutfitItem
     * const outfitItem = await prisma.outfitItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutfitItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OutfitItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutfitItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutfitItems
     * const outfitItems = await prisma.outfitItem.findMany()
     * 
     * // Get first 10 OutfitItems
     * const outfitItems = await prisma.outfitItem.findMany({ take: 10 })
     * 
     * // Only select the `outfitId`
     * const outfitItemWithOutfitIdOnly = await prisma.outfitItem.findMany({ select: { outfitId: true } })
     * 
     */
    findMany<T extends OutfitItemFindManyArgs>(args?: SelectSubset<T, OutfitItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutfitItem.
     * @param {OutfitItemCreateArgs} args - Arguments to create a OutfitItem.
     * @example
     * // Create one OutfitItem
     * const OutfitItem = await prisma.outfitItem.create({
     *   data: {
     *     // ... data to create a OutfitItem
     *   }
     * })
     * 
     */
    create<T extends OutfitItemCreateArgs>(args: SelectSubset<T, OutfitItemCreateArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutfitItems.
     * @param {OutfitItemCreateManyArgs} args - Arguments to create many OutfitItems.
     * @example
     * // Create many OutfitItems
     * const outfitItem = await prisma.outfitItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutfitItemCreateManyArgs>(args?: SelectSubset<T, OutfitItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutfitItems and returns the data saved in the database.
     * @param {OutfitItemCreateManyAndReturnArgs} args - Arguments to create many OutfitItems.
     * @example
     * // Create many OutfitItems
     * const outfitItem = await prisma.outfitItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutfitItems and only return the `outfitId`
     * const outfitItemWithOutfitIdOnly = await prisma.outfitItem.createManyAndReturn({ 
     *   select: { outfitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutfitItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OutfitItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutfitItem.
     * @param {OutfitItemDeleteArgs} args - Arguments to delete one OutfitItem.
     * @example
     * // Delete one OutfitItem
     * const OutfitItem = await prisma.outfitItem.delete({
     *   where: {
     *     // ... filter to delete one OutfitItem
     *   }
     * })
     * 
     */
    delete<T extends OutfitItemDeleteArgs>(args: SelectSubset<T, OutfitItemDeleteArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutfitItem.
     * @param {OutfitItemUpdateArgs} args - Arguments to update one OutfitItem.
     * @example
     * // Update one OutfitItem
     * const outfitItem = await prisma.outfitItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutfitItemUpdateArgs>(args: SelectSubset<T, OutfitItemUpdateArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutfitItems.
     * @param {OutfitItemDeleteManyArgs} args - Arguments to filter OutfitItems to delete.
     * @example
     * // Delete a few OutfitItems
     * const { count } = await prisma.outfitItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutfitItemDeleteManyArgs>(args?: SelectSubset<T, OutfitItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutfitItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutfitItems
     * const outfitItem = await prisma.outfitItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutfitItemUpdateManyArgs>(args: SelectSubset<T, OutfitItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutfitItem.
     * @param {OutfitItemUpsertArgs} args - Arguments to update or create a OutfitItem.
     * @example
     * // Update or create a OutfitItem
     * const outfitItem = await prisma.outfitItem.upsert({
     *   create: {
     *     // ... data to create a OutfitItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutfitItem we want to update
     *   }
     * })
     */
    upsert<T extends OutfitItemUpsertArgs>(args: SelectSubset<T, OutfitItemUpsertArgs<ExtArgs>>): Prisma__OutfitItemClient<$Result.GetResult<Prisma.$OutfitItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutfitItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemCountArgs} args - Arguments to filter OutfitItems to count.
     * @example
     * // Count the number of OutfitItems
     * const count = await prisma.outfitItem.count({
     *   where: {
     *     // ... the filter for the OutfitItems we want to count
     *   }
     * })
    **/
    count<T extends OutfitItemCountArgs>(
      args?: Subset<T, OutfitItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutfitItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutfitItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutfitItemAggregateArgs>(args: Subset<T, OutfitItemAggregateArgs>): Prisma.PrismaPromise<GetOutfitItemAggregateType<T>>

    /**
     * Group by OutfitItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutfitItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutfitItemGroupByArgs['orderBy'] }
        : { orderBy?: OutfitItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutfitItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutfitItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutfitItem model
   */
  readonly fields: OutfitItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutfitItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutfitItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outfit<T extends OutfitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutfitDefaultArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wardrobeItem<T extends WardrobeItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardrobeItemDefaultArgs<ExtArgs>>): Prisma__WardrobeItemClient<$Result.GetResult<Prisma.$WardrobeItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutfitItem model
   */ 
  interface OutfitItemFieldRefs {
    readonly outfitId: FieldRef<"OutfitItem", 'String'>
    readonly wardrobeItemId: FieldRef<"OutfitItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OutfitItem findUnique
   */
  export type OutfitItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitItem to fetch.
     */
    where: OutfitItemWhereUniqueInput
  }

  /**
   * OutfitItem findUniqueOrThrow
   */
  export type OutfitItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitItem to fetch.
     */
    where: OutfitItemWhereUniqueInput
  }

  /**
   * OutfitItem findFirst
   */
  export type OutfitItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitItem to fetch.
     */
    where?: OutfitItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitItems to fetch.
     */
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutfitItems.
     */
    cursor?: OutfitItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutfitItems.
     */
    distinct?: OutfitItemScalarFieldEnum | OutfitItemScalarFieldEnum[]
  }

  /**
   * OutfitItem findFirstOrThrow
   */
  export type OutfitItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitItem to fetch.
     */
    where?: OutfitItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitItems to fetch.
     */
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutfitItems.
     */
    cursor?: OutfitItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutfitItems.
     */
    distinct?: OutfitItemScalarFieldEnum | OutfitItemScalarFieldEnum[]
  }

  /**
   * OutfitItem findMany
   */
  export type OutfitItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitItems to fetch.
     */
    where?: OutfitItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitItems to fetch.
     */
    orderBy?: OutfitItemOrderByWithRelationInput | OutfitItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutfitItems.
     */
    cursor?: OutfitItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitItems.
     */
    skip?: number
    distinct?: OutfitItemScalarFieldEnum | OutfitItemScalarFieldEnum[]
  }

  /**
   * OutfitItem create
   */
  export type OutfitItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OutfitItem.
     */
    data: XOR<OutfitItemCreateInput, OutfitItemUncheckedCreateInput>
  }

  /**
   * OutfitItem createMany
   */
  export type OutfitItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutfitItems.
     */
    data: OutfitItemCreateManyInput | OutfitItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutfitItem createManyAndReturn
   */
  export type OutfitItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutfitItems.
     */
    data: OutfitItemCreateManyInput | OutfitItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutfitItem update
   */
  export type OutfitItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OutfitItem.
     */
    data: XOR<OutfitItemUpdateInput, OutfitItemUncheckedUpdateInput>
    /**
     * Choose, which OutfitItem to update.
     */
    where: OutfitItemWhereUniqueInput
  }

  /**
   * OutfitItem updateMany
   */
  export type OutfitItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutfitItems.
     */
    data: XOR<OutfitItemUpdateManyMutationInput, OutfitItemUncheckedUpdateManyInput>
    /**
     * Filter which OutfitItems to update
     */
    where?: OutfitItemWhereInput
  }

  /**
   * OutfitItem upsert
   */
  export type OutfitItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OutfitItem to update in case it exists.
     */
    where: OutfitItemWhereUniqueInput
    /**
     * In case the OutfitItem found by the `where` argument doesn't exist, create a new OutfitItem with this data.
     */
    create: XOR<OutfitItemCreateInput, OutfitItemUncheckedCreateInput>
    /**
     * In case the OutfitItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutfitItemUpdateInput, OutfitItemUncheckedUpdateInput>
  }

  /**
   * OutfitItem delete
   */
  export type OutfitItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
    /**
     * Filter which OutfitItem to delete.
     */
    where: OutfitItemWhereUniqueInput
  }

  /**
   * OutfitItem deleteMany
   */
  export type OutfitItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutfitItems to delete
     */
    where?: OutfitItemWhereInput
  }

  /**
   * OutfitItem without action
   */
  export type OutfitItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitItem
     */
    select?: OutfitItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitItemInclude<ExtArgs> | null
  }


  /**
   * Model RenderJob
   */

  export type AggregateRenderJob = {
    _count: RenderJobCountAggregateOutputType | null
    _avg: RenderJobAvgAggregateOutputType | null
    _sum: RenderJobSumAggregateOutputType | null
    _min: RenderJobMinAggregateOutputType | null
    _max: RenderJobMaxAggregateOutputType | null
  }

  export type RenderJobAvgAggregateOutputType = {
    attempts: number | null
  }

  export type RenderJobSumAggregateOutputType = {
    attempts: number | null
  }

  export type RenderJobMinAggregateOutputType = {
    id: string | null
    userId: string | null
    outfitId: string | null
    status: string | null
    attempts: number | null
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RenderJobMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    outfitId: string | null
    status: string | null
    attempts: number | null
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RenderJobCountAggregateOutputType = {
    id: number
    userId: number
    outfitId: number
    status: number
    attempts: number
    error: number
    startedAt: number
    finishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RenderJobAvgAggregateInputType = {
    attempts?: true
  }

  export type RenderJobSumAggregateInputType = {
    attempts?: true
  }

  export type RenderJobMinAggregateInputType = {
    id?: true
    userId?: true
    outfitId?: true
    status?: true
    attempts?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RenderJobMaxAggregateInputType = {
    id?: true
    userId?: true
    outfitId?: true
    status?: true
    attempts?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RenderJobCountAggregateInputType = {
    id?: true
    userId?: true
    outfitId?: true
    status?: true
    attempts?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RenderJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RenderJob to aggregate.
     */
    where?: RenderJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RenderJobs to fetch.
     */
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RenderJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RenderJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RenderJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RenderJobs
    **/
    _count?: true | RenderJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RenderJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RenderJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RenderJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RenderJobMaxAggregateInputType
  }

  export type GetRenderJobAggregateType<T extends RenderJobAggregateArgs> = {
        [P in keyof T & keyof AggregateRenderJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRenderJob[P]>
      : GetScalarType<T[P], AggregateRenderJob[P]>
  }




  export type RenderJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RenderJobWhereInput
    orderBy?: RenderJobOrderByWithAggregationInput | RenderJobOrderByWithAggregationInput[]
    by: RenderJobScalarFieldEnum[] | RenderJobScalarFieldEnum
    having?: RenderJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RenderJobCountAggregateInputType | true
    _avg?: RenderJobAvgAggregateInputType
    _sum?: RenderJobSumAggregateInputType
    _min?: RenderJobMinAggregateInputType
    _max?: RenderJobMaxAggregateInputType
  }

  export type RenderJobGroupByOutputType = {
    id: string
    userId: string
    outfitId: string | null
    status: string
    attempts: number
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RenderJobCountAggregateOutputType | null
    _avg: RenderJobAvgAggregateOutputType | null
    _sum: RenderJobSumAggregateOutputType | null
    _min: RenderJobMinAggregateOutputType | null
    _max: RenderJobMaxAggregateOutputType | null
  }

  type GetRenderJobGroupByPayload<T extends RenderJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RenderJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RenderJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RenderJobGroupByOutputType[P]>
            : GetScalarType<T[P], RenderJobGroupByOutputType[P]>
        }
      >
    >


  export type RenderJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    outfitId?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfit?: boolean | RenderJob$outfitArgs<ExtArgs>
  }, ExtArgs["result"]["renderJob"]>

  export type RenderJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    outfitId?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfit?: boolean | RenderJob$outfitArgs<ExtArgs>
  }, ExtArgs["result"]["renderJob"]>

  export type RenderJobSelectScalar = {
    id?: boolean
    userId?: boolean
    outfitId?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RenderJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfit?: boolean | RenderJob$outfitArgs<ExtArgs>
  }
  export type RenderJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfit?: boolean | RenderJob$outfitArgs<ExtArgs>
  }

  export type $RenderJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RenderJob"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      outfit: Prisma.$OutfitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      outfitId: string | null
      status: string
      attempts: number
      error: string | null
      startedAt: Date | null
      finishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["renderJob"]>
    composites: {}
  }

  type RenderJobGetPayload<S extends boolean | null | undefined | RenderJobDefaultArgs> = $Result.GetResult<Prisma.$RenderJobPayload, S>

  type RenderJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RenderJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RenderJobCountAggregateInputType | true
    }

  export interface RenderJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RenderJob'], meta: { name: 'RenderJob' } }
    /**
     * Find zero or one RenderJob that matches the filter.
     * @param {RenderJobFindUniqueArgs} args - Arguments to find a RenderJob
     * @example
     * // Get one RenderJob
     * const renderJob = await prisma.renderJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RenderJobFindUniqueArgs>(args: SelectSubset<T, RenderJobFindUniqueArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RenderJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RenderJobFindUniqueOrThrowArgs} args - Arguments to find a RenderJob
     * @example
     * // Get one RenderJob
     * const renderJob = await prisma.renderJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RenderJobFindUniqueOrThrowArgs>(args: SelectSubset<T, RenderJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RenderJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobFindFirstArgs} args - Arguments to find a RenderJob
     * @example
     * // Get one RenderJob
     * const renderJob = await prisma.renderJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RenderJobFindFirstArgs>(args?: SelectSubset<T, RenderJobFindFirstArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RenderJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobFindFirstOrThrowArgs} args - Arguments to find a RenderJob
     * @example
     * // Get one RenderJob
     * const renderJob = await prisma.renderJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RenderJobFindFirstOrThrowArgs>(args?: SelectSubset<T, RenderJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RenderJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RenderJobs
     * const renderJobs = await prisma.renderJob.findMany()
     * 
     * // Get first 10 RenderJobs
     * const renderJobs = await prisma.renderJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const renderJobWithIdOnly = await prisma.renderJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RenderJobFindManyArgs>(args?: SelectSubset<T, RenderJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RenderJob.
     * @param {RenderJobCreateArgs} args - Arguments to create a RenderJob.
     * @example
     * // Create one RenderJob
     * const RenderJob = await prisma.renderJob.create({
     *   data: {
     *     // ... data to create a RenderJob
     *   }
     * })
     * 
     */
    create<T extends RenderJobCreateArgs>(args: SelectSubset<T, RenderJobCreateArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RenderJobs.
     * @param {RenderJobCreateManyArgs} args - Arguments to create many RenderJobs.
     * @example
     * // Create many RenderJobs
     * const renderJob = await prisma.renderJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RenderJobCreateManyArgs>(args?: SelectSubset<T, RenderJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RenderJobs and returns the data saved in the database.
     * @param {RenderJobCreateManyAndReturnArgs} args - Arguments to create many RenderJobs.
     * @example
     * // Create many RenderJobs
     * const renderJob = await prisma.renderJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RenderJobs and only return the `id`
     * const renderJobWithIdOnly = await prisma.renderJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RenderJobCreateManyAndReturnArgs>(args?: SelectSubset<T, RenderJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RenderJob.
     * @param {RenderJobDeleteArgs} args - Arguments to delete one RenderJob.
     * @example
     * // Delete one RenderJob
     * const RenderJob = await prisma.renderJob.delete({
     *   where: {
     *     // ... filter to delete one RenderJob
     *   }
     * })
     * 
     */
    delete<T extends RenderJobDeleteArgs>(args: SelectSubset<T, RenderJobDeleteArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RenderJob.
     * @param {RenderJobUpdateArgs} args - Arguments to update one RenderJob.
     * @example
     * // Update one RenderJob
     * const renderJob = await prisma.renderJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RenderJobUpdateArgs>(args: SelectSubset<T, RenderJobUpdateArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RenderJobs.
     * @param {RenderJobDeleteManyArgs} args - Arguments to filter RenderJobs to delete.
     * @example
     * // Delete a few RenderJobs
     * const { count } = await prisma.renderJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RenderJobDeleteManyArgs>(args?: SelectSubset<T, RenderJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RenderJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RenderJobs
     * const renderJob = await prisma.renderJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RenderJobUpdateManyArgs>(args: SelectSubset<T, RenderJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RenderJob.
     * @param {RenderJobUpsertArgs} args - Arguments to update or create a RenderJob.
     * @example
     * // Update or create a RenderJob
     * const renderJob = await prisma.renderJob.upsert({
     *   create: {
     *     // ... data to create a RenderJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RenderJob we want to update
     *   }
     * })
     */
    upsert<T extends RenderJobUpsertArgs>(args: SelectSubset<T, RenderJobUpsertArgs<ExtArgs>>): Prisma__RenderJobClient<$Result.GetResult<Prisma.$RenderJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RenderJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobCountArgs} args - Arguments to filter RenderJobs to count.
     * @example
     * // Count the number of RenderJobs
     * const count = await prisma.renderJob.count({
     *   where: {
     *     // ... the filter for the RenderJobs we want to count
     *   }
     * })
    **/
    count<T extends RenderJobCountArgs>(
      args?: Subset<T, RenderJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RenderJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RenderJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RenderJobAggregateArgs>(args: Subset<T, RenderJobAggregateArgs>): Prisma.PrismaPromise<GetRenderJobAggregateType<T>>

    /**
     * Group by RenderJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenderJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RenderJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RenderJobGroupByArgs['orderBy'] }
        : { orderBy?: RenderJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RenderJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRenderJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RenderJob model
   */
  readonly fields: RenderJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RenderJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RenderJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    outfit<T extends RenderJob$outfitArgs<ExtArgs> = {}>(args?: Subset<T, RenderJob$outfitArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RenderJob model
   */ 
  interface RenderJobFieldRefs {
    readonly id: FieldRef<"RenderJob", 'String'>
    readonly userId: FieldRef<"RenderJob", 'String'>
    readonly outfitId: FieldRef<"RenderJob", 'String'>
    readonly status: FieldRef<"RenderJob", 'String'>
    readonly attempts: FieldRef<"RenderJob", 'Int'>
    readonly error: FieldRef<"RenderJob", 'String'>
    readonly startedAt: FieldRef<"RenderJob", 'DateTime'>
    readonly finishedAt: FieldRef<"RenderJob", 'DateTime'>
    readonly createdAt: FieldRef<"RenderJob", 'DateTime'>
    readonly updatedAt: FieldRef<"RenderJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RenderJob findUnique
   */
  export type RenderJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter, which RenderJob to fetch.
     */
    where: RenderJobWhereUniqueInput
  }

  /**
   * RenderJob findUniqueOrThrow
   */
  export type RenderJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter, which RenderJob to fetch.
     */
    where: RenderJobWhereUniqueInput
  }

  /**
   * RenderJob findFirst
   */
  export type RenderJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter, which RenderJob to fetch.
     */
    where?: RenderJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RenderJobs to fetch.
     */
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RenderJobs.
     */
    cursor?: RenderJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RenderJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RenderJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RenderJobs.
     */
    distinct?: RenderJobScalarFieldEnum | RenderJobScalarFieldEnum[]
  }

  /**
   * RenderJob findFirstOrThrow
   */
  export type RenderJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter, which RenderJob to fetch.
     */
    where?: RenderJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RenderJobs to fetch.
     */
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RenderJobs.
     */
    cursor?: RenderJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RenderJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RenderJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RenderJobs.
     */
    distinct?: RenderJobScalarFieldEnum | RenderJobScalarFieldEnum[]
  }

  /**
   * RenderJob findMany
   */
  export type RenderJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter, which RenderJobs to fetch.
     */
    where?: RenderJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RenderJobs to fetch.
     */
    orderBy?: RenderJobOrderByWithRelationInput | RenderJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RenderJobs.
     */
    cursor?: RenderJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RenderJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RenderJobs.
     */
    skip?: number
    distinct?: RenderJobScalarFieldEnum | RenderJobScalarFieldEnum[]
  }

  /**
   * RenderJob create
   */
  export type RenderJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * The data needed to create a RenderJob.
     */
    data: XOR<RenderJobCreateInput, RenderJobUncheckedCreateInput>
  }

  /**
   * RenderJob createMany
   */
  export type RenderJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RenderJobs.
     */
    data: RenderJobCreateManyInput | RenderJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RenderJob createManyAndReturn
   */
  export type RenderJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RenderJobs.
     */
    data: RenderJobCreateManyInput | RenderJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RenderJob update
   */
  export type RenderJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * The data needed to update a RenderJob.
     */
    data: XOR<RenderJobUpdateInput, RenderJobUncheckedUpdateInput>
    /**
     * Choose, which RenderJob to update.
     */
    where: RenderJobWhereUniqueInput
  }

  /**
   * RenderJob updateMany
   */
  export type RenderJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RenderJobs.
     */
    data: XOR<RenderJobUpdateManyMutationInput, RenderJobUncheckedUpdateManyInput>
    /**
     * Filter which RenderJobs to update
     */
    where?: RenderJobWhereInput
  }

  /**
   * RenderJob upsert
   */
  export type RenderJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * The filter to search for the RenderJob to update in case it exists.
     */
    where: RenderJobWhereUniqueInput
    /**
     * In case the RenderJob found by the `where` argument doesn't exist, create a new RenderJob with this data.
     */
    create: XOR<RenderJobCreateInput, RenderJobUncheckedCreateInput>
    /**
     * In case the RenderJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RenderJobUpdateInput, RenderJobUncheckedUpdateInput>
  }

  /**
   * RenderJob delete
   */
  export type RenderJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
    /**
     * Filter which RenderJob to delete.
     */
    where: RenderJobWhereUniqueInput
  }

  /**
   * RenderJob deleteMany
   */
  export type RenderJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RenderJobs to delete
     */
    where?: RenderJobWhereInput
  }

  /**
   * RenderJob.outfit
   */
  export type RenderJob$outfitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    where?: OutfitWhereInput
  }

  /**
   * RenderJob without action
   */
  export type RenderJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenderJob
     */
    select?: RenderJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenderJobInclude<ExtArgs> | null
  }


  /**
   * Model CreditsLedger
   */

  export type AggregateCreditsLedger = {
    _count: CreditsLedgerCountAggregateOutputType | null
    _avg: CreditsLedgerAvgAggregateOutputType | null
    _sum: CreditsLedgerSumAggregateOutputType | null
    _min: CreditsLedgerMinAggregateOutputType | null
    _max: CreditsLedgerMaxAggregateOutputType | null
  }

  export type CreditsLedgerAvgAggregateOutputType = {
    delta: number | null
  }

  export type CreditsLedgerSumAggregateOutputType = {
    delta: number | null
  }

  export type CreditsLedgerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    delta: number | null
    reason: string | null
    refId: string | null
    createdAt: Date | null
  }

  export type CreditsLedgerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    delta: number | null
    reason: string | null
    refId: string | null
    createdAt: Date | null
  }

  export type CreditsLedgerCountAggregateOutputType = {
    id: number
    userId: number
    delta: number
    reason: number
    refId: number
    createdAt: number
    _all: number
  }


  export type CreditsLedgerAvgAggregateInputType = {
    delta?: true
  }

  export type CreditsLedgerSumAggregateInputType = {
    delta?: true
  }

  export type CreditsLedgerMinAggregateInputType = {
    id?: true
    userId?: true
    delta?: true
    reason?: true
    refId?: true
    createdAt?: true
  }

  export type CreditsLedgerMaxAggregateInputType = {
    id?: true
    userId?: true
    delta?: true
    reason?: true
    refId?: true
    createdAt?: true
  }

  export type CreditsLedgerCountAggregateInputType = {
    id?: true
    userId?: true
    delta?: true
    reason?: true
    refId?: true
    createdAt?: true
    _all?: true
  }

  export type CreditsLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditsLedger to aggregate.
     */
    where?: CreditsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsLedgers to fetch.
     */
    orderBy?: CreditsLedgerOrderByWithRelationInput | CreditsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditsLedgers
    **/
    _count?: true | CreditsLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditsLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditsLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditsLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditsLedgerMaxAggregateInputType
  }

  export type GetCreditsLedgerAggregateType<T extends CreditsLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditsLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditsLedger[P]>
      : GetScalarType<T[P], AggregateCreditsLedger[P]>
  }




  export type CreditsLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditsLedgerWhereInput
    orderBy?: CreditsLedgerOrderByWithAggregationInput | CreditsLedgerOrderByWithAggregationInput[]
    by: CreditsLedgerScalarFieldEnum[] | CreditsLedgerScalarFieldEnum
    having?: CreditsLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditsLedgerCountAggregateInputType | true
    _avg?: CreditsLedgerAvgAggregateInputType
    _sum?: CreditsLedgerSumAggregateInputType
    _min?: CreditsLedgerMinAggregateInputType
    _max?: CreditsLedgerMaxAggregateInputType
  }

  export type CreditsLedgerGroupByOutputType = {
    id: string
    userId: string
    delta: number
    reason: string
    refId: string | null
    createdAt: Date
    _count: CreditsLedgerCountAggregateOutputType | null
    _avg: CreditsLedgerAvgAggregateOutputType | null
    _sum: CreditsLedgerSumAggregateOutputType | null
    _min: CreditsLedgerMinAggregateOutputType | null
    _max: CreditsLedgerMaxAggregateOutputType | null
  }

  type GetCreditsLedgerGroupByPayload<T extends CreditsLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditsLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditsLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditsLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], CreditsLedgerGroupByOutputType[P]>
        }
      >
    >


  export type CreditsLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    delta?: boolean
    reason?: boolean
    refId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditsLedger"]>

  export type CreditsLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    delta?: boolean
    reason?: boolean
    refId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditsLedger"]>

  export type CreditsLedgerSelectScalar = {
    id?: boolean
    userId?: boolean
    delta?: boolean
    reason?: boolean
    refId?: boolean
    createdAt?: boolean
  }

  export type CreditsLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditsLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditsLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditsLedger"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      delta: number
      reason: string
      refId: string | null
      createdAt: Date
    }, ExtArgs["result"]["creditsLedger"]>
    composites: {}
  }

  type CreditsLedgerGetPayload<S extends boolean | null | undefined | CreditsLedgerDefaultArgs> = $Result.GetResult<Prisma.$CreditsLedgerPayload, S>

  type CreditsLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreditsLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreditsLedgerCountAggregateInputType | true
    }

  export interface CreditsLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditsLedger'], meta: { name: 'CreditsLedger' } }
    /**
     * Find zero or one CreditsLedger that matches the filter.
     * @param {CreditsLedgerFindUniqueArgs} args - Arguments to find a CreditsLedger
     * @example
     * // Get one CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditsLedgerFindUniqueArgs>(args: SelectSubset<T, CreditsLedgerFindUniqueArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreditsLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreditsLedgerFindUniqueOrThrowArgs} args - Arguments to find a CreditsLedger
     * @example
     * // Get one CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditsLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditsLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreditsLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerFindFirstArgs} args - Arguments to find a CreditsLedger
     * @example
     * // Get one CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditsLedgerFindFirstArgs>(args?: SelectSubset<T, CreditsLedgerFindFirstArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreditsLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerFindFirstOrThrowArgs} args - Arguments to find a CreditsLedger
     * @example
     * // Get one CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditsLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditsLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreditsLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditsLedgers
     * const creditsLedgers = await prisma.creditsLedger.findMany()
     * 
     * // Get first 10 CreditsLedgers
     * const creditsLedgers = await prisma.creditsLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditsLedgerWithIdOnly = await prisma.creditsLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditsLedgerFindManyArgs>(args?: SelectSubset<T, CreditsLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreditsLedger.
     * @param {CreditsLedgerCreateArgs} args - Arguments to create a CreditsLedger.
     * @example
     * // Create one CreditsLedger
     * const CreditsLedger = await prisma.creditsLedger.create({
     *   data: {
     *     // ... data to create a CreditsLedger
     *   }
     * })
     * 
     */
    create<T extends CreditsLedgerCreateArgs>(args: SelectSubset<T, CreditsLedgerCreateArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreditsLedgers.
     * @param {CreditsLedgerCreateManyArgs} args - Arguments to create many CreditsLedgers.
     * @example
     * // Create many CreditsLedgers
     * const creditsLedger = await prisma.creditsLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditsLedgerCreateManyArgs>(args?: SelectSubset<T, CreditsLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditsLedgers and returns the data saved in the database.
     * @param {CreditsLedgerCreateManyAndReturnArgs} args - Arguments to create many CreditsLedgers.
     * @example
     * // Create many CreditsLedgers
     * const creditsLedger = await prisma.creditsLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditsLedgers and only return the `id`
     * const creditsLedgerWithIdOnly = await prisma.creditsLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditsLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditsLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreditsLedger.
     * @param {CreditsLedgerDeleteArgs} args - Arguments to delete one CreditsLedger.
     * @example
     * // Delete one CreditsLedger
     * const CreditsLedger = await prisma.creditsLedger.delete({
     *   where: {
     *     // ... filter to delete one CreditsLedger
     *   }
     * })
     * 
     */
    delete<T extends CreditsLedgerDeleteArgs>(args: SelectSubset<T, CreditsLedgerDeleteArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreditsLedger.
     * @param {CreditsLedgerUpdateArgs} args - Arguments to update one CreditsLedger.
     * @example
     * // Update one CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditsLedgerUpdateArgs>(args: SelectSubset<T, CreditsLedgerUpdateArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreditsLedgers.
     * @param {CreditsLedgerDeleteManyArgs} args - Arguments to filter CreditsLedgers to delete.
     * @example
     * // Delete a few CreditsLedgers
     * const { count } = await prisma.creditsLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditsLedgerDeleteManyArgs>(args?: SelectSubset<T, CreditsLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditsLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditsLedgers
     * const creditsLedger = await prisma.creditsLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditsLedgerUpdateManyArgs>(args: SelectSubset<T, CreditsLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditsLedger.
     * @param {CreditsLedgerUpsertArgs} args - Arguments to update or create a CreditsLedger.
     * @example
     * // Update or create a CreditsLedger
     * const creditsLedger = await prisma.creditsLedger.upsert({
     *   create: {
     *     // ... data to create a CreditsLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditsLedger we want to update
     *   }
     * })
     */
    upsert<T extends CreditsLedgerUpsertArgs>(args: SelectSubset<T, CreditsLedgerUpsertArgs<ExtArgs>>): Prisma__CreditsLedgerClient<$Result.GetResult<Prisma.$CreditsLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreditsLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerCountArgs} args - Arguments to filter CreditsLedgers to count.
     * @example
     * // Count the number of CreditsLedgers
     * const count = await prisma.creditsLedger.count({
     *   where: {
     *     // ... the filter for the CreditsLedgers we want to count
     *   }
     * })
    **/
    count<T extends CreditsLedgerCountArgs>(
      args?: Subset<T, CreditsLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditsLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditsLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditsLedgerAggregateArgs>(args: Subset<T, CreditsLedgerAggregateArgs>): Prisma.PrismaPromise<GetCreditsLedgerAggregateType<T>>

    /**
     * Group by CreditsLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditsLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditsLedgerGroupByArgs['orderBy'] }
        : { orderBy?: CreditsLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditsLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditsLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditsLedger model
   */
  readonly fields: CreditsLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditsLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditsLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditsLedger model
   */ 
  interface CreditsLedgerFieldRefs {
    readonly id: FieldRef<"CreditsLedger", 'String'>
    readonly userId: FieldRef<"CreditsLedger", 'String'>
    readonly delta: FieldRef<"CreditsLedger", 'Int'>
    readonly reason: FieldRef<"CreditsLedger", 'String'>
    readonly refId: FieldRef<"CreditsLedger", 'String'>
    readonly createdAt: FieldRef<"CreditsLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditsLedger findUnique
   */
  export type CreditsLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CreditsLedger to fetch.
     */
    where: CreditsLedgerWhereUniqueInput
  }

  /**
   * CreditsLedger findUniqueOrThrow
   */
  export type CreditsLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CreditsLedger to fetch.
     */
    where: CreditsLedgerWhereUniqueInput
  }

  /**
   * CreditsLedger findFirst
   */
  export type CreditsLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CreditsLedger to fetch.
     */
    where?: CreditsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsLedgers to fetch.
     */
    orderBy?: CreditsLedgerOrderByWithRelationInput | CreditsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditsLedgers.
     */
    cursor?: CreditsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditsLedgers.
     */
    distinct?: CreditsLedgerScalarFieldEnum | CreditsLedgerScalarFieldEnum[]
  }

  /**
   * CreditsLedger findFirstOrThrow
   */
  export type CreditsLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CreditsLedger to fetch.
     */
    where?: CreditsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsLedgers to fetch.
     */
    orderBy?: CreditsLedgerOrderByWithRelationInput | CreditsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditsLedgers.
     */
    cursor?: CreditsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditsLedgers.
     */
    distinct?: CreditsLedgerScalarFieldEnum | CreditsLedgerScalarFieldEnum[]
  }

  /**
   * CreditsLedger findMany
   */
  export type CreditsLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CreditsLedgers to fetch.
     */
    where?: CreditsLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsLedgers to fetch.
     */
    orderBy?: CreditsLedgerOrderByWithRelationInput | CreditsLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditsLedgers.
     */
    cursor?: CreditsLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsLedgers.
     */
    skip?: number
    distinct?: CreditsLedgerScalarFieldEnum | CreditsLedgerScalarFieldEnum[]
  }

  /**
   * CreditsLedger create
   */
  export type CreditsLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditsLedger.
     */
    data: XOR<CreditsLedgerCreateInput, CreditsLedgerUncheckedCreateInput>
  }

  /**
   * CreditsLedger createMany
   */
  export type CreditsLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditsLedgers.
     */
    data: CreditsLedgerCreateManyInput | CreditsLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditsLedger createManyAndReturn
   */
  export type CreditsLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreditsLedgers.
     */
    data: CreditsLedgerCreateManyInput | CreditsLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditsLedger update
   */
  export type CreditsLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditsLedger.
     */
    data: XOR<CreditsLedgerUpdateInput, CreditsLedgerUncheckedUpdateInput>
    /**
     * Choose, which CreditsLedger to update.
     */
    where: CreditsLedgerWhereUniqueInput
  }

  /**
   * CreditsLedger updateMany
   */
  export type CreditsLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditsLedgers.
     */
    data: XOR<CreditsLedgerUpdateManyMutationInput, CreditsLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CreditsLedgers to update
     */
    where?: CreditsLedgerWhereInput
  }

  /**
   * CreditsLedger upsert
   */
  export type CreditsLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditsLedger to update in case it exists.
     */
    where: CreditsLedgerWhereUniqueInput
    /**
     * In case the CreditsLedger found by the `where` argument doesn't exist, create a new CreditsLedger with this data.
     */
    create: XOR<CreditsLedgerCreateInput, CreditsLedgerUncheckedCreateInput>
    /**
     * In case the CreditsLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditsLedgerUpdateInput, CreditsLedgerUncheckedUpdateInput>
  }

  /**
   * CreditsLedger delete
   */
  export type CreditsLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
    /**
     * Filter which CreditsLedger to delete.
     */
    where: CreditsLedgerWhereUniqueInput
  }

  /**
   * CreditsLedger deleteMany
   */
  export type CreditsLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditsLedgers to delete
     */
    where?: CreditsLedgerWhereInput
  }

  /**
   * CreditsLedger without action
   */
  export type CreditsLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsLedger
     */
    select?: CreditsLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsLedgerInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    status: string | null
    platform: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    appleOriginalTransactionId: string | null
    appleProductId: string | null
    appleReceiptData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    status: string | null
    platform: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    appleOriginalTransactionId: string | null
    appleProductId: string | null
    appleReceiptData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    status: number
    platform: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    appleOriginalTransactionId: number
    appleProductId: number
    appleReceiptData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    platform?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    appleOriginalTransactionId?: true
    appleProductId?: true
    appleReceiptData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    platform?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    appleOriginalTransactionId?: true
    appleProductId?: true
    appleReceiptData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    platform?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    appleOriginalTransactionId?: true
    appleProductId?: true
    appleReceiptData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    plan: string
    status: string
    platform: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    appleOriginalTransactionId: string | null
    appleProductId: string | null
    appleReceiptData: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    platform?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: boolean
    appleProductId?: boolean
    appleReceiptData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchases?: boolean | Subscription$purchasesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    platform?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: boolean
    appleProductId?: boolean
    appleReceiptData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    platform?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: boolean
    appleProductId?: boolean
    appleReceiptData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchases?: boolean | Subscription$purchasesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      plan: string
      status: string
      platform: string | null
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      appleOriginalTransactionId: string | null
      appleProductId: string | null
      appleReceiptData: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchases<T extends Subscription$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly platform: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly appleOriginalTransactionId: FieldRef<"Subscription", 'String'>
    readonly appleProductId: FieldRef<"Subscription", 'String'>
    readonly appleReceiptData: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.purchases
   */
  export type Subscription$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    amountCents: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    platform: string | null
    externalId: string | null
    productId: string | null
    plan: string | null
    status: string | null
    amountCents: number | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    platform: string | null
    externalId: string | null
    productId: string | null
    plan: string | null
    status: string | null
    amountCents: number | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    platform: number
    externalId: number
    productId: number
    plan: number
    status: number
    amountCents: number
    currency: number
    periodStart: number
    periodEnd: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    amountCents?: true
  }

  export type PurchaseSumAggregateInputType = {
    amountCents?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    platform?: true
    externalId?: true
    productId?: true
    plan?: true
    status?: true
    amountCents?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    platform?: true
    externalId?: true
    productId?: true
    plan?: true
    status?: true
    amountCents?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    platform?: true
    externalId?: true
    productId?: true
    plan?: true
    status?: true
    amountCents?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    userId: string
    subscriptionId: string | null
    platform: string
    externalId: string
    productId: string
    plan: string
    status: string
    amountCents: number | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    platform?: boolean
    externalId?: boolean
    productId?: boolean
    plan?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Purchase$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    platform?: boolean
    externalId?: boolean
    productId?: boolean
    plan?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Purchase$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    platform?: boolean
    externalId?: boolean
    productId?: boolean
    plan?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Purchase$subscriptionArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Purchase$subscriptionArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subscriptionId: string | null
      platform: string
      externalId: string
      productId: string
      plan: string
      status: string
      amountCents: number | null
      currency: string | null
      periodStart: Date | null
      periodEnd: Date | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscription<T extends Purchase$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly userId: FieldRef<"Purchase", 'String'>
    readonly subscriptionId: FieldRef<"Purchase", 'String'>
    readonly platform: FieldRef<"Purchase", 'String'>
    readonly externalId: FieldRef<"Purchase", 'String'>
    readonly productId: FieldRef<"Purchase", 'String'>
    readonly plan: FieldRef<"Purchase", 'String'>
    readonly status: FieldRef<"Purchase", 'String'>
    readonly amountCents: FieldRef<"Purchase", 'Int'>
    readonly currency: FieldRef<"Purchase", 'String'>
    readonly periodStart: FieldRef<"Purchase", 'DateTime'>
    readonly periodEnd: FieldRef<"Purchase", 'DateTime'>
    readonly metadata: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase.subscription
   */
  export type Purchase$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Usage
   */

  export type AggregateUsage = {
    _count: UsageCountAggregateOutputType | null
    _avg: UsageAvgAggregateOutputType | null
    _sum: UsageSumAggregateOutputType | null
    _min: UsageMinAggregateOutputType | null
    _max: UsageMaxAggregateOutputType | null
  }

  export type UsageAvgAggregateOutputType = {
    aiGenerationsCount: number | null
    virtualTryonCount: number | null
    weeklyGenerationCount: number | null
  }

  export type UsageSumAggregateOutputType = {
    aiGenerationsCount: number | null
    virtualTryonCount: number | null
    weeklyGenerationCount: number | null
  }

  export type UsageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    aiGenerationsCount: number | null
    virtualTryonCount: number | null
    weeklyGenerationCount: number | null
    createdAt: Date | null
  }

  export type UsageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    aiGenerationsCount: number | null
    virtualTryonCount: number | null
    weeklyGenerationCount: number | null
    createdAt: Date | null
  }

  export type UsageCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    aiGenerationsCount: number
    virtualTryonCount: number
    weeklyGenerationCount: number
    createdAt: number
    _all: number
  }


  export type UsageAvgAggregateInputType = {
    aiGenerationsCount?: true
    virtualTryonCount?: true
    weeklyGenerationCount?: true
  }

  export type UsageSumAggregateInputType = {
    aiGenerationsCount?: true
    virtualTryonCount?: true
    weeklyGenerationCount?: true
  }

  export type UsageMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    aiGenerationsCount?: true
    virtualTryonCount?: true
    weeklyGenerationCount?: true
    createdAt?: true
  }

  export type UsageMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    aiGenerationsCount?: true
    virtualTryonCount?: true
    weeklyGenerationCount?: true
    createdAt?: true
  }

  export type UsageCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    aiGenerationsCount?: true
    virtualTryonCount?: true
    weeklyGenerationCount?: true
    createdAt?: true
    _all?: true
  }

  export type UsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usage to aggregate.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usages
    **/
    _count?: true | UsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMaxAggregateInputType
  }

  export type GetUsageAggregateType<T extends UsageAggregateArgs> = {
        [P in keyof T & keyof AggregateUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsage[P]>
      : GetScalarType<T[P], AggregateUsage[P]>
  }




  export type UsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageWhereInput
    orderBy?: UsageOrderByWithAggregationInput | UsageOrderByWithAggregationInput[]
    by: UsageScalarFieldEnum[] | UsageScalarFieldEnum
    having?: UsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageCountAggregateInputType | true
    _avg?: UsageAvgAggregateInputType
    _sum?: UsageSumAggregateInputType
    _min?: UsageMinAggregateInputType
    _max?: UsageMaxAggregateInputType
  }

  export type UsageGroupByOutputType = {
    id: string
    userId: string
    month: string
    aiGenerationsCount: number
    virtualTryonCount: number
    weeklyGenerationCount: number
    createdAt: Date
    _count: UsageCountAggregateOutputType | null
    _avg: UsageAvgAggregateOutputType | null
    _sum: UsageSumAggregateOutputType | null
    _min: UsageMinAggregateOutputType | null
    _max: UsageMaxAggregateOutputType | null
  }

  type GetUsageGroupByPayload<T extends UsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageGroupByOutputType[P]>
            : GetScalarType<T[P], UsageGroupByOutputType[P]>
        }
      >
    >


  export type UsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    aiGenerationsCount?: boolean
    virtualTryonCount?: boolean
    weeklyGenerationCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usage"]>

  export type UsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    aiGenerationsCount?: boolean
    virtualTryonCount?: boolean
    weeklyGenerationCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usage"]>

  export type UsageSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    aiGenerationsCount?: boolean
    virtualTryonCount?: boolean
    weeklyGenerationCount?: boolean
    createdAt?: boolean
  }

  export type UsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      month: string
      aiGenerationsCount: number
      virtualTryonCount: number
      weeklyGenerationCount: number
      createdAt: Date
    }, ExtArgs["result"]["usage"]>
    composites: {}
  }

  type UsageGetPayload<S extends boolean | null | undefined | UsageDefaultArgs> = $Result.GetResult<Prisma.$UsagePayload, S>

  type UsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageCountAggregateInputType | true
    }

  export interface UsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usage'], meta: { name: 'Usage' } }
    /**
     * Find zero or one Usage that matches the filter.
     * @param {UsageFindUniqueArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageFindUniqueArgs>(args: SelectSubset<T, UsageFindUniqueArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageFindUniqueOrThrowArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindFirstArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageFindFirstArgs>(args?: SelectSubset<T, UsageFindFirstArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindFirstOrThrowArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usages
     * const usages = await prisma.usage.findMany()
     * 
     * // Get first 10 Usages
     * const usages = await prisma.usage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageWithIdOnly = await prisma.usage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageFindManyArgs>(args?: SelectSubset<T, UsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usage.
     * @param {UsageCreateArgs} args - Arguments to create a Usage.
     * @example
     * // Create one Usage
     * const Usage = await prisma.usage.create({
     *   data: {
     *     // ... data to create a Usage
     *   }
     * })
     * 
     */
    create<T extends UsageCreateArgs>(args: SelectSubset<T, UsageCreateArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usages.
     * @param {UsageCreateManyArgs} args - Arguments to create many Usages.
     * @example
     * // Create many Usages
     * const usage = await prisma.usage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageCreateManyArgs>(args?: SelectSubset<T, UsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usages and returns the data saved in the database.
     * @param {UsageCreateManyAndReturnArgs} args - Arguments to create many Usages.
     * @example
     * // Create many Usages
     * const usage = await prisma.usage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usages and only return the `id`
     * const usageWithIdOnly = await prisma.usage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usage.
     * @param {UsageDeleteArgs} args - Arguments to delete one Usage.
     * @example
     * // Delete one Usage
     * const Usage = await prisma.usage.delete({
     *   where: {
     *     // ... filter to delete one Usage
     *   }
     * })
     * 
     */
    delete<T extends UsageDeleteArgs>(args: SelectSubset<T, UsageDeleteArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usage.
     * @param {UsageUpdateArgs} args - Arguments to update one Usage.
     * @example
     * // Update one Usage
     * const usage = await prisma.usage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageUpdateArgs>(args: SelectSubset<T, UsageUpdateArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usages.
     * @param {UsageDeleteManyArgs} args - Arguments to filter Usages to delete.
     * @example
     * // Delete a few Usages
     * const { count } = await prisma.usage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageDeleteManyArgs>(args?: SelectSubset<T, UsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usages
     * const usage = await prisma.usage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageUpdateManyArgs>(args: SelectSubset<T, UsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usage.
     * @param {UsageUpsertArgs} args - Arguments to update or create a Usage.
     * @example
     * // Update or create a Usage
     * const usage = await prisma.usage.upsert({
     *   create: {
     *     // ... data to create a Usage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usage we want to update
     *   }
     * })
     */
    upsert<T extends UsageUpsertArgs>(args: SelectSubset<T, UsageUpsertArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCountArgs} args - Arguments to filter Usages to count.
     * @example
     * // Count the number of Usages
     * const count = await prisma.usage.count({
     *   where: {
     *     // ... the filter for the Usages we want to count
     *   }
     * })
    **/
    count<T extends UsageCountArgs>(
      args?: Subset<T, UsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageAggregateArgs>(args: Subset<T, UsageAggregateArgs>): Prisma.PrismaPromise<GetUsageAggregateType<T>>

    /**
     * Group by Usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageGroupByArgs['orderBy'] }
        : { orderBy?: UsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usage model
   */
  readonly fields: UsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usage model
   */ 
  interface UsageFieldRefs {
    readonly id: FieldRef<"Usage", 'String'>
    readonly userId: FieldRef<"Usage", 'String'>
    readonly month: FieldRef<"Usage", 'String'>
    readonly aiGenerationsCount: FieldRef<"Usage", 'Int'>
    readonly virtualTryonCount: FieldRef<"Usage", 'Int'>
    readonly weeklyGenerationCount: FieldRef<"Usage", 'Int'>
    readonly createdAt: FieldRef<"Usage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usage findUnique
   */
  export type UsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage findUniqueOrThrow
   */
  export type UsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage findFirst
   */
  export type UsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usages.
     */
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage findFirstOrThrow
   */
  export type UsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usages.
     */
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage findMany
   */
  export type UsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usages to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage create
   */
  export type UsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The data needed to create a Usage.
     */
    data: XOR<UsageCreateInput, UsageUncheckedCreateInput>
  }

  /**
   * Usage createMany
   */
  export type UsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usages.
     */
    data: UsageCreateManyInput | UsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usage createManyAndReturn
   */
  export type UsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usages.
     */
    data: UsageCreateManyInput | UsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usage update
   */
  export type UsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The data needed to update a Usage.
     */
    data: XOR<UsageUpdateInput, UsageUncheckedUpdateInput>
    /**
     * Choose, which Usage to update.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage updateMany
   */
  export type UsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usages.
     */
    data: XOR<UsageUpdateManyMutationInput, UsageUncheckedUpdateManyInput>
    /**
     * Filter which Usages to update
     */
    where?: UsageWhereInput
  }

  /**
   * Usage upsert
   */
  export type UsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The filter to search for the Usage to update in case it exists.
     */
    where: UsageWhereUniqueInput
    /**
     * In case the Usage found by the `where` argument doesn't exist, create a new Usage with this data.
     */
    create: XOR<UsageCreateInput, UsageUncheckedCreateInput>
    /**
     * In case the Usage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageUpdateInput, UsageUncheckedUpdateInput>
  }

  /**
   * Usage delete
   */
  export type UsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter which Usage to delete.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage deleteMany
   */
  export type UsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usages to delete
     */
    where?: UsageWhereInput
  }

  /**
   * Usage without action
   */
  export type UsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
  }


  /**
   * Model EventAnalytics
   */

  export type AggregateEventAnalytics = {
    _count: EventAnalyticsCountAggregateOutputType | null
    _min: EventAnalyticsMinAggregateOutputType | null
    _max: EventAnalyticsMaxAggregateOutputType | null
  }

  export type EventAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventName: string | null
    props: string | null
    createdAt: Date | null
  }

  export type EventAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventName: string | null
    props: string | null
    createdAt: Date | null
  }

  export type EventAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    eventName: number
    props: number
    createdAt: number
    _all: number
  }


  export type EventAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    props?: true
    createdAt?: true
  }

  export type EventAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    props?: true
    createdAt?: true
  }

  export type EventAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    props?: true
    createdAt?: true
    _all?: true
  }

  export type EventAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAnalytics to aggregate.
     */
    where?: EventAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAnalytics to fetch.
     */
    orderBy?: EventAnalyticsOrderByWithRelationInput | EventAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventAnalytics
    **/
    _count?: true | EventAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventAnalyticsMaxAggregateInputType
  }

  export type GetEventAnalyticsAggregateType<T extends EventAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateEventAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventAnalytics[P]>
      : GetScalarType<T[P], AggregateEventAnalytics[P]>
  }




  export type EventAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAnalyticsWhereInput
    orderBy?: EventAnalyticsOrderByWithAggregationInput | EventAnalyticsOrderByWithAggregationInput[]
    by: EventAnalyticsScalarFieldEnum[] | EventAnalyticsScalarFieldEnum
    having?: EventAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventAnalyticsCountAggregateInputType | true
    _min?: EventAnalyticsMinAggregateInputType
    _max?: EventAnalyticsMaxAggregateInputType
  }

  export type EventAnalyticsGroupByOutputType = {
    id: string
    userId: string | null
    eventName: string
    props: string | null
    createdAt: Date
    _count: EventAnalyticsCountAggregateOutputType | null
    _min: EventAnalyticsMinAggregateOutputType | null
    _max: EventAnalyticsMaxAggregateOutputType | null
  }

  type GetEventAnalyticsGroupByPayload<T extends EventAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], EventAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type EventAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventName?: boolean
    props?: boolean
    createdAt?: boolean
    user?: boolean | EventAnalytics$userArgs<ExtArgs>
  }, ExtArgs["result"]["eventAnalytics"]>

  export type EventAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventName?: boolean
    props?: boolean
    createdAt?: boolean
    user?: boolean | EventAnalytics$userArgs<ExtArgs>
  }, ExtArgs["result"]["eventAnalytics"]>

  export type EventAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    eventName?: boolean
    props?: boolean
    createdAt?: boolean
  }

  export type EventAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EventAnalytics$userArgs<ExtArgs>
  }
  export type EventAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EventAnalytics$userArgs<ExtArgs>
  }

  export type $EventAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventName: string
      props: string | null
      createdAt: Date
    }, ExtArgs["result"]["eventAnalytics"]>
    composites: {}
  }

  type EventAnalyticsGetPayload<S extends boolean | null | undefined | EventAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$EventAnalyticsPayload, S>

  type EventAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventAnalyticsCountAggregateInputType | true
    }

  export interface EventAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventAnalytics'], meta: { name: 'EventAnalytics' } }
    /**
     * Find zero or one EventAnalytics that matches the filter.
     * @param {EventAnalyticsFindUniqueArgs} args - Arguments to find a EventAnalytics
     * @example
     * // Get one EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventAnalyticsFindUniqueArgs>(args: SelectSubset<T, EventAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a EventAnalytics
     * @example
     * // Get one EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsFindFirstArgs} args - Arguments to find a EventAnalytics
     * @example
     * // Get one EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventAnalyticsFindFirstArgs>(args?: SelectSubset<T, EventAnalyticsFindFirstArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsFindFirstOrThrowArgs} args - Arguments to find a EventAnalytics
     * @example
     * // Get one EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findMany()
     * 
     * // Get first 10 EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventAnalyticsWithIdOnly = await prisma.eventAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventAnalyticsFindManyArgs>(args?: SelectSubset<T, EventAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventAnalytics.
     * @param {EventAnalyticsCreateArgs} args - Arguments to create a EventAnalytics.
     * @example
     * // Create one EventAnalytics
     * const EventAnalytics = await prisma.eventAnalytics.create({
     *   data: {
     *     // ... data to create a EventAnalytics
     *   }
     * })
     * 
     */
    create<T extends EventAnalyticsCreateArgs>(args: SelectSubset<T, EventAnalyticsCreateArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventAnalytics.
     * @param {EventAnalyticsCreateManyArgs} args - Arguments to create many EventAnalytics.
     * @example
     * // Create many EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventAnalyticsCreateManyArgs>(args?: SelectSubset<T, EventAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventAnalytics and returns the data saved in the database.
     * @param {EventAnalyticsCreateManyAndReturnArgs} args - Arguments to create many EventAnalytics.
     * @example
     * // Create many EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventAnalytics and only return the `id`
     * const eventAnalyticsWithIdOnly = await prisma.eventAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventAnalytics.
     * @param {EventAnalyticsDeleteArgs} args - Arguments to delete one EventAnalytics.
     * @example
     * // Delete one EventAnalytics
     * const EventAnalytics = await prisma.eventAnalytics.delete({
     *   where: {
     *     // ... filter to delete one EventAnalytics
     *   }
     * })
     * 
     */
    delete<T extends EventAnalyticsDeleteArgs>(args: SelectSubset<T, EventAnalyticsDeleteArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventAnalytics.
     * @param {EventAnalyticsUpdateArgs} args - Arguments to update one EventAnalytics.
     * @example
     * // Update one EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventAnalyticsUpdateArgs>(args: SelectSubset<T, EventAnalyticsUpdateArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventAnalytics.
     * @param {EventAnalyticsDeleteManyArgs} args - Arguments to filter EventAnalytics to delete.
     * @example
     * // Delete a few EventAnalytics
     * const { count } = await prisma.eventAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventAnalyticsDeleteManyArgs>(args?: SelectSubset<T, EventAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventAnalyticsUpdateManyArgs>(args: SelectSubset<T, EventAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventAnalytics.
     * @param {EventAnalyticsUpsertArgs} args - Arguments to update or create a EventAnalytics.
     * @example
     * // Update or create a EventAnalytics
     * const eventAnalytics = await prisma.eventAnalytics.upsert({
     *   create: {
     *     // ... data to create a EventAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends EventAnalyticsUpsertArgs>(args: SelectSubset<T, EventAnalyticsUpsertArgs<ExtArgs>>): Prisma__EventAnalyticsClient<$Result.GetResult<Prisma.$EventAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsCountArgs} args - Arguments to filter EventAnalytics to count.
     * @example
     * // Count the number of EventAnalytics
     * const count = await prisma.eventAnalytics.count({
     *   where: {
     *     // ... the filter for the EventAnalytics we want to count
     *   }
     * })
    **/
    count<T extends EventAnalyticsCountArgs>(
      args?: Subset<T, EventAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAnalyticsAggregateArgs>(args: Subset<T, EventAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetEventAnalyticsAggregateType<T>>

    /**
     * Group by EventAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: EventAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventAnalytics model
   */
  readonly fields: EventAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends EventAnalytics$userArgs<ExtArgs> = {}>(args?: Subset<T, EventAnalytics$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventAnalytics model
   */ 
  interface EventAnalyticsFieldRefs {
    readonly id: FieldRef<"EventAnalytics", 'String'>
    readonly userId: FieldRef<"EventAnalytics", 'String'>
    readonly eventName: FieldRef<"EventAnalytics", 'String'>
    readonly props: FieldRef<"EventAnalytics", 'String'>
    readonly createdAt: FieldRef<"EventAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventAnalytics findUnique
   */
  export type EventAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EventAnalytics to fetch.
     */
    where: EventAnalyticsWhereUniqueInput
  }

  /**
   * EventAnalytics findUniqueOrThrow
   */
  export type EventAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EventAnalytics to fetch.
     */
    where: EventAnalyticsWhereUniqueInput
  }

  /**
   * EventAnalytics findFirst
   */
  export type EventAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EventAnalytics to fetch.
     */
    where?: EventAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAnalytics to fetch.
     */
    orderBy?: EventAnalyticsOrderByWithRelationInput | EventAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAnalytics.
     */
    cursor?: EventAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAnalytics.
     */
    distinct?: EventAnalyticsScalarFieldEnum | EventAnalyticsScalarFieldEnum[]
  }

  /**
   * EventAnalytics findFirstOrThrow
   */
  export type EventAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EventAnalytics to fetch.
     */
    where?: EventAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAnalytics to fetch.
     */
    orderBy?: EventAnalyticsOrderByWithRelationInput | EventAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAnalytics.
     */
    cursor?: EventAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAnalytics.
     */
    distinct?: EventAnalyticsScalarFieldEnum | EventAnalyticsScalarFieldEnum[]
  }

  /**
   * EventAnalytics findMany
   */
  export type EventAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which EventAnalytics to fetch.
     */
    where?: EventAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAnalytics to fetch.
     */
    orderBy?: EventAnalyticsOrderByWithRelationInput | EventAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventAnalytics.
     */
    cursor?: EventAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAnalytics.
     */
    skip?: number
    distinct?: EventAnalyticsScalarFieldEnum | EventAnalyticsScalarFieldEnum[]
  }

  /**
   * EventAnalytics create
   */
  export type EventAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a EventAnalytics.
     */
    data: XOR<EventAnalyticsCreateInput, EventAnalyticsUncheckedCreateInput>
  }

  /**
   * EventAnalytics createMany
   */
  export type EventAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventAnalytics.
     */
    data: EventAnalyticsCreateManyInput | EventAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventAnalytics createManyAndReturn
   */
  export type EventAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventAnalytics.
     */
    data: EventAnalyticsCreateManyInput | EventAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAnalytics update
   */
  export type EventAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a EventAnalytics.
     */
    data: XOR<EventAnalyticsUpdateInput, EventAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which EventAnalytics to update.
     */
    where: EventAnalyticsWhereUniqueInput
  }

  /**
   * EventAnalytics updateMany
   */
  export type EventAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventAnalytics.
     */
    data: XOR<EventAnalyticsUpdateManyMutationInput, EventAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which EventAnalytics to update
     */
    where?: EventAnalyticsWhereInput
  }

  /**
   * EventAnalytics upsert
   */
  export type EventAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the EventAnalytics to update in case it exists.
     */
    where: EventAnalyticsWhereUniqueInput
    /**
     * In case the EventAnalytics found by the `where` argument doesn't exist, create a new EventAnalytics with this data.
     */
    create: XOR<EventAnalyticsCreateInput, EventAnalyticsUncheckedCreateInput>
    /**
     * In case the EventAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventAnalyticsUpdateInput, EventAnalyticsUncheckedUpdateInput>
  }

  /**
   * EventAnalytics delete
   */
  export type EventAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which EventAnalytics to delete.
     */
    where: EventAnalyticsWhereUniqueInput
  }

  /**
   * EventAnalytics deleteMany
   */
  export type EventAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAnalytics to delete
     */
    where?: EventAnalyticsWhereInput
  }

  /**
   * EventAnalytics.user
   */
  export type EventAnalytics$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EventAnalytics without action
   */
  export type EventAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAnalytics
     */
    select?: EventAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model HelpCenterConversation
   */

  export type AggregateHelpCenterConversation = {
    _count: HelpCenterConversationCountAggregateOutputType | null
    _min: HelpCenterConversationMinAggregateOutputType | null
    _max: HelpCenterConversationMaxAggregateOutputType | null
  }

  export type HelpCenterConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCenterConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCenterConversationCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpCenterConversationMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCenterConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCenterConversationCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpCenterConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCenterConversation to aggregate.
     */
    where?: HelpCenterConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterConversations to fetch.
     */
    orderBy?: HelpCenterConversationOrderByWithRelationInput | HelpCenterConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpCenterConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpCenterConversations
    **/
    _count?: true | HelpCenterConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCenterConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCenterConversationMaxAggregateInputType
  }

  export type GetHelpCenterConversationAggregateType<T extends HelpCenterConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCenterConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCenterConversation[P]>
      : GetScalarType<T[P], AggregateHelpCenterConversation[P]>
  }




  export type HelpCenterConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCenterConversationWhereInput
    orderBy?: HelpCenterConversationOrderByWithAggregationInput | HelpCenterConversationOrderByWithAggregationInput[]
    by: HelpCenterConversationScalarFieldEnum[] | HelpCenterConversationScalarFieldEnum
    having?: HelpCenterConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCenterConversationCountAggregateInputType | true
    _min?: HelpCenterConversationMinAggregateInputType
    _max?: HelpCenterConversationMaxAggregateInputType
  }

  export type HelpCenterConversationGroupByOutputType = {
    id: string
    userId: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: HelpCenterConversationCountAggregateOutputType | null
    _min: HelpCenterConversationMinAggregateOutputType | null
    _max: HelpCenterConversationMaxAggregateOutputType | null
  }

  type GetHelpCenterConversationGroupByPayload<T extends HelpCenterConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCenterConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCenterConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCenterConversationGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCenterConversationGroupByOutputType[P]>
        }
      >
    >


  export type HelpCenterConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | HelpCenterConversation$messagesArgs<ExtArgs>
    _count?: boolean | HelpCenterConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCenterConversation"]>

  export type HelpCenterConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCenterConversation"]>

  export type HelpCenterConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpCenterConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | HelpCenterConversation$messagesArgs<ExtArgs>
    _count?: boolean | HelpCenterConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelpCenterConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelpCenterConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpCenterConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$HelpCenterMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpCenterConversation"]>
    composites: {}
  }

  type HelpCenterConversationGetPayload<S extends boolean | null | undefined | HelpCenterConversationDefaultArgs> = $Result.GetResult<Prisma.$HelpCenterConversationPayload, S>

  type HelpCenterConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpCenterConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCenterConversationCountAggregateInputType | true
    }

  export interface HelpCenterConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpCenterConversation'], meta: { name: 'HelpCenterConversation' } }
    /**
     * Find zero or one HelpCenterConversation that matches the filter.
     * @param {HelpCenterConversationFindUniqueArgs} args - Arguments to find a HelpCenterConversation
     * @example
     * // Get one HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpCenterConversationFindUniqueArgs>(args: SelectSubset<T, HelpCenterConversationFindUniqueArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpCenterConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpCenterConversationFindUniqueOrThrowArgs} args - Arguments to find a HelpCenterConversation
     * @example
     * // Get one HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpCenterConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpCenterConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpCenterConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationFindFirstArgs} args - Arguments to find a HelpCenterConversation
     * @example
     * // Get one HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpCenterConversationFindFirstArgs>(args?: SelectSubset<T, HelpCenterConversationFindFirstArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpCenterConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationFindFirstOrThrowArgs} args - Arguments to find a HelpCenterConversation
     * @example
     * // Get one HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpCenterConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpCenterConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpCenterConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCenterConversations
     * const helpCenterConversations = await prisma.helpCenterConversation.findMany()
     * 
     * // Get first 10 HelpCenterConversations
     * const helpCenterConversations = await prisma.helpCenterConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCenterConversationWithIdOnly = await prisma.helpCenterConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpCenterConversationFindManyArgs>(args?: SelectSubset<T, HelpCenterConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpCenterConversation.
     * @param {HelpCenterConversationCreateArgs} args - Arguments to create a HelpCenterConversation.
     * @example
     * // Create one HelpCenterConversation
     * const HelpCenterConversation = await prisma.helpCenterConversation.create({
     *   data: {
     *     // ... data to create a HelpCenterConversation
     *   }
     * })
     * 
     */
    create<T extends HelpCenterConversationCreateArgs>(args: SelectSubset<T, HelpCenterConversationCreateArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpCenterConversations.
     * @param {HelpCenterConversationCreateManyArgs} args - Arguments to create many HelpCenterConversations.
     * @example
     * // Create many HelpCenterConversations
     * const helpCenterConversation = await prisma.helpCenterConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCenterConversationCreateManyArgs>(args?: SelectSubset<T, HelpCenterConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpCenterConversations and returns the data saved in the database.
     * @param {HelpCenterConversationCreateManyAndReturnArgs} args - Arguments to create many HelpCenterConversations.
     * @example
     * // Create many HelpCenterConversations
     * const helpCenterConversation = await prisma.helpCenterConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpCenterConversations and only return the `id`
     * const helpCenterConversationWithIdOnly = await prisma.helpCenterConversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpCenterConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpCenterConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpCenterConversation.
     * @param {HelpCenterConversationDeleteArgs} args - Arguments to delete one HelpCenterConversation.
     * @example
     * // Delete one HelpCenterConversation
     * const HelpCenterConversation = await prisma.helpCenterConversation.delete({
     *   where: {
     *     // ... filter to delete one HelpCenterConversation
     *   }
     * })
     * 
     */
    delete<T extends HelpCenterConversationDeleteArgs>(args: SelectSubset<T, HelpCenterConversationDeleteArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpCenterConversation.
     * @param {HelpCenterConversationUpdateArgs} args - Arguments to update one HelpCenterConversation.
     * @example
     * // Update one HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpCenterConversationUpdateArgs>(args: SelectSubset<T, HelpCenterConversationUpdateArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpCenterConversations.
     * @param {HelpCenterConversationDeleteManyArgs} args - Arguments to filter HelpCenterConversations to delete.
     * @example
     * // Delete a few HelpCenterConversations
     * const { count } = await prisma.helpCenterConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpCenterConversationDeleteManyArgs>(args?: SelectSubset<T, HelpCenterConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCenterConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCenterConversations
     * const helpCenterConversation = await prisma.helpCenterConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpCenterConversationUpdateManyArgs>(args: SelectSubset<T, HelpCenterConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpCenterConversation.
     * @param {HelpCenterConversationUpsertArgs} args - Arguments to update or create a HelpCenterConversation.
     * @example
     * // Update or create a HelpCenterConversation
     * const helpCenterConversation = await prisma.helpCenterConversation.upsert({
     *   create: {
     *     // ... data to create a HelpCenterConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCenterConversation we want to update
     *   }
     * })
     */
    upsert<T extends HelpCenterConversationUpsertArgs>(args: SelectSubset<T, HelpCenterConversationUpsertArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpCenterConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationCountArgs} args - Arguments to filter HelpCenterConversations to count.
     * @example
     * // Count the number of HelpCenterConversations
     * const count = await prisma.helpCenterConversation.count({
     *   where: {
     *     // ... the filter for the HelpCenterConversations we want to count
     *   }
     * })
    **/
    count<T extends HelpCenterConversationCountArgs>(
      args?: Subset<T, HelpCenterConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCenterConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCenterConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCenterConversationAggregateArgs>(args: Subset<T, HelpCenterConversationAggregateArgs>): Prisma.PrismaPromise<GetHelpCenterConversationAggregateType<T>>

    /**
     * Group by HelpCenterConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpCenterConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpCenterConversationGroupByArgs['orderBy'] }
        : { orderBy?: HelpCenterConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpCenterConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCenterConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpCenterConversation model
   */
  readonly fields: HelpCenterConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpCenterConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpCenterConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends HelpCenterConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, HelpCenterConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpCenterConversation model
   */ 
  interface HelpCenterConversationFieldRefs {
    readonly id: FieldRef<"HelpCenterConversation", 'String'>
    readonly userId: FieldRef<"HelpCenterConversation", 'String'>
    readonly status: FieldRef<"HelpCenterConversation", 'String'>
    readonly createdAt: FieldRef<"HelpCenterConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpCenterConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpCenterConversation findUnique
   */
  export type HelpCenterConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterConversation to fetch.
     */
    where: HelpCenterConversationWhereUniqueInput
  }

  /**
   * HelpCenterConversation findUniqueOrThrow
   */
  export type HelpCenterConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterConversation to fetch.
     */
    where: HelpCenterConversationWhereUniqueInput
  }

  /**
   * HelpCenterConversation findFirst
   */
  export type HelpCenterConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterConversation to fetch.
     */
    where?: HelpCenterConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterConversations to fetch.
     */
    orderBy?: HelpCenterConversationOrderByWithRelationInput | HelpCenterConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCenterConversations.
     */
    cursor?: HelpCenterConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCenterConversations.
     */
    distinct?: HelpCenterConversationScalarFieldEnum | HelpCenterConversationScalarFieldEnum[]
  }

  /**
   * HelpCenterConversation findFirstOrThrow
   */
  export type HelpCenterConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterConversation to fetch.
     */
    where?: HelpCenterConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterConversations to fetch.
     */
    orderBy?: HelpCenterConversationOrderByWithRelationInput | HelpCenterConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCenterConversations.
     */
    cursor?: HelpCenterConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCenterConversations.
     */
    distinct?: HelpCenterConversationScalarFieldEnum | HelpCenterConversationScalarFieldEnum[]
  }

  /**
   * HelpCenterConversation findMany
   */
  export type HelpCenterConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterConversations to fetch.
     */
    where?: HelpCenterConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterConversations to fetch.
     */
    orderBy?: HelpCenterConversationOrderByWithRelationInput | HelpCenterConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpCenterConversations.
     */
    cursor?: HelpCenterConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterConversations.
     */
    skip?: number
    distinct?: HelpCenterConversationScalarFieldEnum | HelpCenterConversationScalarFieldEnum[]
  }

  /**
   * HelpCenterConversation create
   */
  export type HelpCenterConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpCenterConversation.
     */
    data: XOR<HelpCenterConversationCreateInput, HelpCenterConversationUncheckedCreateInput>
  }

  /**
   * HelpCenterConversation createMany
   */
  export type HelpCenterConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpCenterConversations.
     */
    data: HelpCenterConversationCreateManyInput | HelpCenterConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpCenterConversation createManyAndReturn
   */
  export type HelpCenterConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpCenterConversations.
     */
    data: HelpCenterConversationCreateManyInput | HelpCenterConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpCenterConversation update
   */
  export type HelpCenterConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpCenterConversation.
     */
    data: XOR<HelpCenterConversationUpdateInput, HelpCenterConversationUncheckedUpdateInput>
    /**
     * Choose, which HelpCenterConversation to update.
     */
    where: HelpCenterConversationWhereUniqueInput
  }

  /**
   * HelpCenterConversation updateMany
   */
  export type HelpCenterConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpCenterConversations.
     */
    data: XOR<HelpCenterConversationUpdateManyMutationInput, HelpCenterConversationUncheckedUpdateManyInput>
    /**
     * Filter which HelpCenterConversations to update
     */
    where?: HelpCenterConversationWhereInput
  }

  /**
   * HelpCenterConversation upsert
   */
  export type HelpCenterConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpCenterConversation to update in case it exists.
     */
    where: HelpCenterConversationWhereUniqueInput
    /**
     * In case the HelpCenterConversation found by the `where` argument doesn't exist, create a new HelpCenterConversation with this data.
     */
    create: XOR<HelpCenterConversationCreateInput, HelpCenterConversationUncheckedCreateInput>
    /**
     * In case the HelpCenterConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpCenterConversationUpdateInput, HelpCenterConversationUncheckedUpdateInput>
  }

  /**
   * HelpCenterConversation delete
   */
  export type HelpCenterConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
    /**
     * Filter which HelpCenterConversation to delete.
     */
    where: HelpCenterConversationWhereUniqueInput
  }

  /**
   * HelpCenterConversation deleteMany
   */
  export type HelpCenterConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCenterConversations to delete
     */
    where?: HelpCenterConversationWhereInput
  }

  /**
   * HelpCenterConversation.messages
   */
  export type HelpCenterConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    where?: HelpCenterMessageWhereInput
    orderBy?: HelpCenterMessageOrderByWithRelationInput | HelpCenterMessageOrderByWithRelationInput[]
    cursor?: HelpCenterMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpCenterMessageScalarFieldEnum | HelpCenterMessageScalarFieldEnum[]
  }

  /**
   * HelpCenterConversation without action
   */
  export type HelpCenterConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterConversation
     */
    select?: HelpCenterConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterConversationInclude<ExtArgs> | null
  }


  /**
   * Model HelpCenterMessage
   */

  export type AggregateHelpCenterMessage = {
    _count: HelpCenterMessageCountAggregateOutputType | null
    _min: HelpCenterMessageMinAggregateOutputType | null
    _max: HelpCenterMessageMaxAggregateOutputType | null
  }

  export type HelpCenterMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    sender: string | null
    text: string | null
    createdAt: Date | null
  }

  export type HelpCenterMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    sender: string | null
    text: string | null
    createdAt: Date | null
  }

  export type HelpCenterMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    sender: number
    text: number
    createdAt: number
    _all: number
  }


  export type HelpCenterMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    sender?: true
    text?: true
    createdAt?: true
  }

  export type HelpCenterMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    sender?: true
    text?: true
    createdAt?: true
  }

  export type HelpCenterMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    sender?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type HelpCenterMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCenterMessage to aggregate.
     */
    where?: HelpCenterMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterMessages to fetch.
     */
    orderBy?: HelpCenterMessageOrderByWithRelationInput | HelpCenterMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpCenterMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpCenterMessages
    **/
    _count?: true | HelpCenterMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCenterMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCenterMessageMaxAggregateInputType
  }

  export type GetHelpCenterMessageAggregateType<T extends HelpCenterMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCenterMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCenterMessage[P]>
      : GetScalarType<T[P], AggregateHelpCenterMessage[P]>
  }




  export type HelpCenterMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCenterMessageWhereInput
    orderBy?: HelpCenterMessageOrderByWithAggregationInput | HelpCenterMessageOrderByWithAggregationInput[]
    by: HelpCenterMessageScalarFieldEnum[] | HelpCenterMessageScalarFieldEnum
    having?: HelpCenterMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCenterMessageCountAggregateInputType | true
    _min?: HelpCenterMessageMinAggregateInputType
    _max?: HelpCenterMessageMaxAggregateInputType
  }

  export type HelpCenterMessageGroupByOutputType = {
    id: string
    conversationId: string
    sender: string
    text: string
    createdAt: Date
    _count: HelpCenterMessageCountAggregateOutputType | null
    _min: HelpCenterMessageMinAggregateOutputType | null
    _max: HelpCenterMessageMaxAggregateOutputType | null
  }

  type GetHelpCenterMessageGroupByPayload<T extends HelpCenterMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCenterMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCenterMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCenterMessageGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCenterMessageGroupByOutputType[P]>
        }
      >
    >


  export type HelpCenterMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    sender?: boolean
    text?: boolean
    createdAt?: boolean
    conversation?: boolean | HelpCenterConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCenterMessage"]>

  export type HelpCenterMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    sender?: boolean
    text?: boolean
    createdAt?: boolean
    conversation?: boolean | HelpCenterConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCenterMessage"]>

  export type HelpCenterMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    sender?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type HelpCenterMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | HelpCenterConversationDefaultArgs<ExtArgs>
  }
  export type HelpCenterMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | HelpCenterConversationDefaultArgs<ExtArgs>
  }

  export type $HelpCenterMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpCenterMessage"
    objects: {
      conversation: Prisma.$HelpCenterConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      sender: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["helpCenterMessage"]>
    composites: {}
  }

  type HelpCenterMessageGetPayload<S extends boolean | null | undefined | HelpCenterMessageDefaultArgs> = $Result.GetResult<Prisma.$HelpCenterMessagePayload, S>

  type HelpCenterMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpCenterMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCenterMessageCountAggregateInputType | true
    }

  export interface HelpCenterMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpCenterMessage'], meta: { name: 'HelpCenterMessage' } }
    /**
     * Find zero or one HelpCenterMessage that matches the filter.
     * @param {HelpCenterMessageFindUniqueArgs} args - Arguments to find a HelpCenterMessage
     * @example
     * // Get one HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpCenterMessageFindUniqueArgs>(args: SelectSubset<T, HelpCenterMessageFindUniqueArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpCenterMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpCenterMessageFindUniqueOrThrowArgs} args - Arguments to find a HelpCenterMessage
     * @example
     * // Get one HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpCenterMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpCenterMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpCenterMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageFindFirstArgs} args - Arguments to find a HelpCenterMessage
     * @example
     * // Get one HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpCenterMessageFindFirstArgs>(args?: SelectSubset<T, HelpCenterMessageFindFirstArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpCenterMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageFindFirstOrThrowArgs} args - Arguments to find a HelpCenterMessage
     * @example
     * // Get one HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpCenterMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpCenterMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpCenterMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCenterMessages
     * const helpCenterMessages = await prisma.helpCenterMessage.findMany()
     * 
     * // Get first 10 HelpCenterMessages
     * const helpCenterMessages = await prisma.helpCenterMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCenterMessageWithIdOnly = await prisma.helpCenterMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpCenterMessageFindManyArgs>(args?: SelectSubset<T, HelpCenterMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpCenterMessage.
     * @param {HelpCenterMessageCreateArgs} args - Arguments to create a HelpCenterMessage.
     * @example
     * // Create one HelpCenterMessage
     * const HelpCenterMessage = await prisma.helpCenterMessage.create({
     *   data: {
     *     // ... data to create a HelpCenterMessage
     *   }
     * })
     * 
     */
    create<T extends HelpCenterMessageCreateArgs>(args: SelectSubset<T, HelpCenterMessageCreateArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpCenterMessages.
     * @param {HelpCenterMessageCreateManyArgs} args - Arguments to create many HelpCenterMessages.
     * @example
     * // Create many HelpCenterMessages
     * const helpCenterMessage = await prisma.helpCenterMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCenterMessageCreateManyArgs>(args?: SelectSubset<T, HelpCenterMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpCenterMessages and returns the data saved in the database.
     * @param {HelpCenterMessageCreateManyAndReturnArgs} args - Arguments to create many HelpCenterMessages.
     * @example
     * // Create many HelpCenterMessages
     * const helpCenterMessage = await prisma.helpCenterMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpCenterMessages and only return the `id`
     * const helpCenterMessageWithIdOnly = await prisma.helpCenterMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpCenterMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpCenterMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpCenterMessage.
     * @param {HelpCenterMessageDeleteArgs} args - Arguments to delete one HelpCenterMessage.
     * @example
     * // Delete one HelpCenterMessage
     * const HelpCenterMessage = await prisma.helpCenterMessage.delete({
     *   where: {
     *     // ... filter to delete one HelpCenterMessage
     *   }
     * })
     * 
     */
    delete<T extends HelpCenterMessageDeleteArgs>(args: SelectSubset<T, HelpCenterMessageDeleteArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpCenterMessage.
     * @param {HelpCenterMessageUpdateArgs} args - Arguments to update one HelpCenterMessage.
     * @example
     * // Update one HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpCenterMessageUpdateArgs>(args: SelectSubset<T, HelpCenterMessageUpdateArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpCenterMessages.
     * @param {HelpCenterMessageDeleteManyArgs} args - Arguments to filter HelpCenterMessages to delete.
     * @example
     * // Delete a few HelpCenterMessages
     * const { count } = await prisma.helpCenterMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpCenterMessageDeleteManyArgs>(args?: SelectSubset<T, HelpCenterMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCenterMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCenterMessages
     * const helpCenterMessage = await prisma.helpCenterMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpCenterMessageUpdateManyArgs>(args: SelectSubset<T, HelpCenterMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpCenterMessage.
     * @param {HelpCenterMessageUpsertArgs} args - Arguments to update or create a HelpCenterMessage.
     * @example
     * // Update or create a HelpCenterMessage
     * const helpCenterMessage = await prisma.helpCenterMessage.upsert({
     *   create: {
     *     // ... data to create a HelpCenterMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCenterMessage we want to update
     *   }
     * })
     */
    upsert<T extends HelpCenterMessageUpsertArgs>(args: SelectSubset<T, HelpCenterMessageUpsertArgs<ExtArgs>>): Prisma__HelpCenterMessageClient<$Result.GetResult<Prisma.$HelpCenterMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpCenterMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageCountArgs} args - Arguments to filter HelpCenterMessages to count.
     * @example
     * // Count the number of HelpCenterMessages
     * const count = await prisma.helpCenterMessage.count({
     *   where: {
     *     // ... the filter for the HelpCenterMessages we want to count
     *   }
     * })
    **/
    count<T extends HelpCenterMessageCountArgs>(
      args?: Subset<T, HelpCenterMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCenterMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCenterMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCenterMessageAggregateArgs>(args: Subset<T, HelpCenterMessageAggregateArgs>): Prisma.PrismaPromise<GetHelpCenterMessageAggregateType<T>>

    /**
     * Group by HelpCenterMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCenterMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpCenterMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpCenterMessageGroupByArgs['orderBy'] }
        : { orderBy?: HelpCenterMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpCenterMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCenterMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpCenterMessage model
   */
  readonly fields: HelpCenterMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpCenterMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpCenterMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends HelpCenterConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpCenterConversationDefaultArgs<ExtArgs>>): Prisma__HelpCenterConversationClient<$Result.GetResult<Prisma.$HelpCenterConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpCenterMessage model
   */ 
  interface HelpCenterMessageFieldRefs {
    readonly id: FieldRef<"HelpCenterMessage", 'String'>
    readonly conversationId: FieldRef<"HelpCenterMessage", 'String'>
    readonly sender: FieldRef<"HelpCenterMessage", 'String'>
    readonly text: FieldRef<"HelpCenterMessage", 'String'>
    readonly createdAt: FieldRef<"HelpCenterMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpCenterMessage findUnique
   */
  export type HelpCenterMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterMessage to fetch.
     */
    where: HelpCenterMessageWhereUniqueInput
  }

  /**
   * HelpCenterMessage findUniqueOrThrow
   */
  export type HelpCenterMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterMessage to fetch.
     */
    where: HelpCenterMessageWhereUniqueInput
  }

  /**
   * HelpCenterMessage findFirst
   */
  export type HelpCenterMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterMessage to fetch.
     */
    where?: HelpCenterMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterMessages to fetch.
     */
    orderBy?: HelpCenterMessageOrderByWithRelationInput | HelpCenterMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCenterMessages.
     */
    cursor?: HelpCenterMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCenterMessages.
     */
    distinct?: HelpCenterMessageScalarFieldEnum | HelpCenterMessageScalarFieldEnum[]
  }

  /**
   * HelpCenterMessage findFirstOrThrow
   */
  export type HelpCenterMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterMessage to fetch.
     */
    where?: HelpCenterMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterMessages to fetch.
     */
    orderBy?: HelpCenterMessageOrderByWithRelationInput | HelpCenterMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCenterMessages.
     */
    cursor?: HelpCenterMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCenterMessages.
     */
    distinct?: HelpCenterMessageScalarFieldEnum | HelpCenterMessageScalarFieldEnum[]
  }

  /**
   * HelpCenterMessage findMany
   */
  export type HelpCenterMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpCenterMessages to fetch.
     */
    where?: HelpCenterMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCenterMessages to fetch.
     */
    orderBy?: HelpCenterMessageOrderByWithRelationInput | HelpCenterMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpCenterMessages.
     */
    cursor?: HelpCenterMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCenterMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCenterMessages.
     */
    skip?: number
    distinct?: HelpCenterMessageScalarFieldEnum | HelpCenterMessageScalarFieldEnum[]
  }

  /**
   * HelpCenterMessage create
   */
  export type HelpCenterMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpCenterMessage.
     */
    data: XOR<HelpCenterMessageCreateInput, HelpCenterMessageUncheckedCreateInput>
  }

  /**
   * HelpCenterMessage createMany
   */
  export type HelpCenterMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpCenterMessages.
     */
    data: HelpCenterMessageCreateManyInput | HelpCenterMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpCenterMessage createManyAndReturn
   */
  export type HelpCenterMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpCenterMessages.
     */
    data: HelpCenterMessageCreateManyInput | HelpCenterMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpCenterMessage update
   */
  export type HelpCenterMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpCenterMessage.
     */
    data: XOR<HelpCenterMessageUpdateInput, HelpCenterMessageUncheckedUpdateInput>
    /**
     * Choose, which HelpCenterMessage to update.
     */
    where: HelpCenterMessageWhereUniqueInput
  }

  /**
   * HelpCenterMessage updateMany
   */
  export type HelpCenterMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpCenterMessages.
     */
    data: XOR<HelpCenterMessageUpdateManyMutationInput, HelpCenterMessageUncheckedUpdateManyInput>
    /**
     * Filter which HelpCenterMessages to update
     */
    where?: HelpCenterMessageWhereInput
  }

  /**
   * HelpCenterMessage upsert
   */
  export type HelpCenterMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpCenterMessage to update in case it exists.
     */
    where: HelpCenterMessageWhereUniqueInput
    /**
     * In case the HelpCenterMessage found by the `where` argument doesn't exist, create a new HelpCenterMessage with this data.
     */
    create: XOR<HelpCenterMessageCreateInput, HelpCenterMessageUncheckedCreateInput>
    /**
     * In case the HelpCenterMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpCenterMessageUpdateInput, HelpCenterMessageUncheckedUpdateInput>
  }

  /**
   * HelpCenterMessage delete
   */
  export type HelpCenterMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
    /**
     * Filter which HelpCenterMessage to delete.
     */
    where: HelpCenterMessageWhereUniqueInput
  }

  /**
   * HelpCenterMessage deleteMany
   */
  export type HelpCenterMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCenterMessages to delete
     */
    where?: HelpCenterMessageWhereInput
  }

  /**
   * HelpCenterMessage without action
   */
  export type HelpCenterMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCenterMessage
     */
    select?: HelpCenterMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCenterMessageInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    coldThresholdC: number | null
    hotThresholdC: number | null
    tempChangeThresholdC: number | null
    minHoursBetweenNotifs: number | null
  }

  export type NotificationSettingsSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    coldThresholdC: number | null
    hotThresholdC: number | null
    tempChangeThresholdC: number | null
    minHoursBetweenNotifs: number | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    enabled: boolean | null
    expoPushToken: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    notifyAtLocalTime: string | null
    coldThresholdC: number | null
    hotThresholdC: number | null
    tempChangeThresholdC: number | null
    notifyOnWeatherChange: boolean | null
    minHoursBetweenNotifs: number | null
    lastNotifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    enabled: boolean | null
    expoPushToken: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    notifyAtLocalTime: string | null
    coldThresholdC: number | null
    hotThresholdC: number | null
    tempChangeThresholdC: number | null
    notifyOnWeatherChange: boolean | null
    minHoursBetweenNotifs: number | null
    lastNotifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    enabled: number
    expoPushToken: number
    latitude: number
    longitude: number
    timezone: number
    notifyAtLocalTime: number
    coldThresholdC: number
    hotThresholdC: number
    tempChangeThresholdC: number
    notifyOnWeatherChange: number
    minHoursBetweenNotifs: number
    lastNotifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingsAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    coldThresholdC?: true
    hotThresholdC?: true
    tempChangeThresholdC?: true
    minHoursBetweenNotifs?: true
  }

  export type NotificationSettingsSumAggregateInputType = {
    latitude?: true
    longitude?: true
    coldThresholdC?: true
    hotThresholdC?: true
    tempChangeThresholdC?: true
    minHoursBetweenNotifs?: true
  }

  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    enabled?: true
    expoPushToken?: true
    latitude?: true
    longitude?: true
    timezone?: true
    notifyAtLocalTime?: true
    coldThresholdC?: true
    hotThresholdC?: true
    tempChangeThresholdC?: true
    notifyOnWeatherChange?: true
    minHoursBetweenNotifs?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    enabled?: true
    expoPushToken?: true
    latitude?: true
    longitude?: true
    timezone?: true
    notifyAtLocalTime?: true
    coldThresholdC?: true
    hotThresholdC?: true
    tempChangeThresholdC?: true
    notifyOnWeatherChange?: true
    minHoursBetweenNotifs?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    enabled?: true
    expoPushToken?: true
    latitude?: true
    longitude?: true
    timezone?: true
    notifyAtLocalTime?: true
    coldThresholdC?: true
    hotThresholdC?: true
    tempChangeThresholdC?: true
    notifyOnWeatherChange?: true
    minHoursBetweenNotifs?: true
    lastNotifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _avg?: NotificationSettingsAvgAggregateInputType
    _sum?: NotificationSettingsSumAggregateInputType
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    userId: string
    enabled: boolean
    expoPushToken: string | null
    latitude: number | null
    longitude: number | null
    timezone: string
    notifyAtLocalTime: string
    coldThresholdC: number
    hotThresholdC: number
    tempChangeThresholdC: number
    notifyOnWeatherChange: boolean
    minHoursBetweenNotifs: number
    lastNotifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    enabled?: boolean
    expoPushToken?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    notifyAtLocalTime?: boolean
    coldThresholdC?: boolean
    hotThresholdC?: boolean
    tempChangeThresholdC?: boolean
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    enabled?: boolean
    expoPushToken?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    notifyAtLocalTime?: boolean
    coldThresholdC?: boolean
    hotThresholdC?: boolean
    tempChangeThresholdC?: boolean
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    enabled?: boolean
    expoPushToken?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    notifyAtLocalTime?: boolean
    coldThresholdC?: boolean
    hotThresholdC?: boolean
    tempChangeThresholdC?: boolean
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: boolean
    lastNotifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      enabled: boolean
      expoPushToken: string | null
      latitude: number | null
      longitude: number | null
      timezone: string
      notifyAtLocalTime: string
      coldThresholdC: number
      hotThresholdC: number
      tempChangeThresholdC: number
      notifyOnWeatherChange: boolean
      minHoursBetweenNotifs: number
      lastNotifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
    readonly enabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly expoPushToken: FieldRef<"NotificationSettings", 'String'>
    readonly latitude: FieldRef<"NotificationSettings", 'Float'>
    readonly longitude: FieldRef<"NotificationSettings", 'Float'>
    readonly timezone: FieldRef<"NotificationSettings", 'String'>
    readonly notifyAtLocalTime: FieldRef<"NotificationSettings", 'String'>
    readonly coldThresholdC: FieldRef<"NotificationSettings", 'Float'>
    readonly hotThresholdC: FieldRef<"NotificationSettings", 'Float'>
    readonly tempChangeThresholdC: FieldRef<"NotificationSettings", 'Float'>
    readonly notifyOnWeatherChange: FieldRef<"NotificationSettings", 'Boolean'>
    readonly minHoursBetweenNotifs: FieldRef<"NotificationSettings", 'Int'>
    readonly lastNotifiedAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    data: string | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    data: string | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    body: number
    data: number
    sentAt: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    data?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    data?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    data?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    body: string
    data: string | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      body: string
      data: string | null
      sentAt: Date | null
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    avatarBaseImageUrl: 'avatarBaseImageUrl',
    onboardingStatus: 'onboardingStatus',
    sex: 'sex',
    age: 'age',
    heightCm: 'heightCm',
    emailVerificationCode: 'emailVerificationCode',
    emailVerificationExpires: 'emailVerificationExpires',
    emailVerifiedAt: 'emailVerifiedAt',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPhotoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    imageUrl: 'imageUrl',
    isPrimary: 'isPrimary',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPhotoScalarFieldEnum = (typeof UserPhotoScalarFieldEnum)[keyof typeof UserPhotoScalarFieldEnum]


  export const WardrobeItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    imageUrl: 'imageUrl',
    cutoutImageUrl: 'cutoutImageUrl',
    cutoutStatus: 'cutoutStatus',
    cutoutError: 'cutoutError',
    category: 'category',
    colorFamily: 'colorFamily',
    colorHex: 'colorHex',
    styleTags: 'styleTags',
    seasonTags: 'seasonTags',
    fitTag: 'fitTag',
    extraTags: 'extraTags',
    confidence: 'confidence',
    rawAiJson: 'rawAiJson',
    userNotes: 'userNotes',
    productType: 'productType',
    color: 'color',
    tags: 'tags',
    brand: 'brand',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WardrobeItemScalarFieldEnum = (typeof WardrobeItemScalarFieldEnum)[keyof typeof WardrobeItemScalarFieldEnum]


  export const OutfitScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    weekStartDate: 'weekStartDate',
    dayIndex: 'dayIndex',
    status: 'status',
    imageUrl: 'imageUrl',
    promptVersion: 'promptVersion',
    weather: 'weather',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutfitScalarFieldEnum = (typeof OutfitScalarFieldEnum)[keyof typeof OutfitScalarFieldEnum]


  export const OutfitItemScalarFieldEnum: {
    outfitId: 'outfitId',
    wardrobeItemId: 'wardrobeItemId'
  };

  export type OutfitItemScalarFieldEnum = (typeof OutfitItemScalarFieldEnum)[keyof typeof OutfitItemScalarFieldEnum]


  export const RenderJobScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    outfitId: 'outfitId',
    status: 'status',
    attempts: 'attempts',
    error: 'error',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RenderJobScalarFieldEnum = (typeof RenderJobScalarFieldEnum)[keyof typeof RenderJobScalarFieldEnum]


  export const CreditsLedgerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    delta: 'delta',
    reason: 'reason',
    refId: 'refId',
    createdAt: 'createdAt'
  };

  export type CreditsLedgerScalarFieldEnum = (typeof CreditsLedgerScalarFieldEnum)[keyof typeof CreditsLedgerScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    status: 'status',
    platform: 'platform',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    appleOriginalTransactionId: 'appleOriginalTransactionId',
    appleProductId: 'appleProductId',
    appleReceiptData: 'appleReceiptData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    platform: 'platform',
    externalId: 'externalId',
    productId: 'productId',
    plan: 'plan',
    status: 'status',
    amountCents: 'amountCents',
    currency: 'currency',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const UsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    aiGenerationsCount: 'aiGenerationsCount',
    virtualTryonCount: 'virtualTryonCount',
    weeklyGenerationCount: 'weeklyGenerationCount',
    createdAt: 'createdAt'
  };

  export type UsageScalarFieldEnum = (typeof UsageScalarFieldEnum)[keyof typeof UsageScalarFieldEnum]


  export const EventAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventName: 'eventName',
    props: 'props',
    createdAt: 'createdAt'
  };

  export type EventAnalyticsScalarFieldEnum = (typeof EventAnalyticsScalarFieldEnum)[keyof typeof EventAnalyticsScalarFieldEnum]


  export const HelpCenterConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpCenterConversationScalarFieldEnum = (typeof HelpCenterConversationScalarFieldEnum)[keyof typeof HelpCenterConversationScalarFieldEnum]


  export const HelpCenterMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    sender: 'sender',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type HelpCenterMessageScalarFieldEnum = (typeof HelpCenterMessageScalarFieldEnum)[keyof typeof HelpCenterMessageScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    enabled: 'enabled',
    expoPushToken: 'expoPushToken',
    latitude: 'latitude',
    longitude: 'longitude',
    timezone: 'timezone',
    notifyAtLocalTime: 'notifyAtLocalTime',
    coldThresholdC: 'coldThresholdC',
    hotThresholdC: 'hotThresholdC',
    tempChangeThresholdC: 'tempChangeThresholdC',
    notifyOnWeatherChange: 'notifyOnWeatherChange',
    minHoursBetweenNotifs: 'minHoursBetweenNotifs',
    lastNotifiedAt: 'lastNotifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    data: 'data',
    sentAt: 'sentAt',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    avatarBaseImageUrl?: StringNullableFilter<"User"> | string | null
    onboardingStatus?: StringFilter<"User"> | string
    sex?: StringNullableFilter<"User"> | string | null
    age?: IntNullableFilter<"User"> | number | null
    heightCm?: IntNullableFilter<"User"> | number | null
    emailVerificationCode?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    photos?: UserPhotoListRelationFilter
    wardrobeItems?: WardrobeItemListRelationFilter
    outfits?: OutfitListRelationFilter
    renderJobs?: RenderJobListRelationFilter
    creditsLedger?: CreditsLedgerListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    purchases?: PurchaseListRelationFilter
    usageRecords?: UsageListRelationFilter
    eventsAnalytics?: EventAnalyticsListRelationFilter
    notificationSettings?: XOR<NotificationSettingsNullableRelationFilter, NotificationSettingsWhereInput> | null
    notifications?: NotificationListRelationFilter
    helpCenterConversation?: XOR<HelpCenterConversationNullableRelationFilter, HelpCenterConversationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    avatarBaseImageUrl?: SortOrderInput | SortOrder
    onboardingStatus?: SortOrder
    sex?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    emailVerificationCode?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photos?: UserPhotoOrderByRelationAggregateInput
    wardrobeItems?: WardrobeItemOrderByRelationAggregateInput
    outfits?: OutfitOrderByRelationAggregateInput
    renderJobs?: RenderJobOrderByRelationAggregateInput
    creditsLedger?: CreditsLedgerOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    usageRecords?: UsageOrderByRelationAggregateInput
    eventsAnalytics?: EventAnalyticsOrderByRelationAggregateInput
    notificationSettings?: NotificationSettingsOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    helpCenterConversation?: HelpCenterConversationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    avatarBaseImageUrl?: StringNullableFilter<"User"> | string | null
    onboardingStatus?: StringFilter<"User"> | string
    sex?: StringNullableFilter<"User"> | string | null
    age?: IntNullableFilter<"User"> | number | null
    heightCm?: IntNullableFilter<"User"> | number | null
    emailVerificationCode?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    photos?: UserPhotoListRelationFilter
    wardrobeItems?: WardrobeItemListRelationFilter
    outfits?: OutfitListRelationFilter
    renderJobs?: RenderJobListRelationFilter
    creditsLedger?: CreditsLedgerListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    purchases?: PurchaseListRelationFilter
    usageRecords?: UsageListRelationFilter
    eventsAnalytics?: EventAnalyticsListRelationFilter
    notificationSettings?: XOR<NotificationSettingsNullableRelationFilter, NotificationSettingsWhereInput> | null
    notifications?: NotificationListRelationFilter
    helpCenterConversation?: XOR<HelpCenterConversationNullableRelationFilter, HelpCenterConversationWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    avatarBaseImageUrl?: SortOrderInput | SortOrder
    onboardingStatus?: SortOrder
    sex?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    emailVerificationCode?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarBaseImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    onboardingStatus?: StringWithAggregatesFilter<"User"> | string
    sex?: StringNullableWithAggregatesFilter<"User"> | string | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    heightCm?: IntNullableWithAggregatesFilter<"User"> | number | null
    emailVerificationCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPhotoWhereInput = {
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    imageUrl?: StringFilter<"UserPhoto"> | string
    isPrimary?: BoolFilter<"UserPhoto"> | boolean
    metadata?: StringNullableFilter<"UserPhoto"> | string | null
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPhotoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    isPrimary?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    userId?: StringFilter<"UserPhoto"> | string
    imageUrl?: StringFilter<"UserPhoto"> | string
    isPrimary?: BoolFilter<"UserPhoto"> | boolean
    metadata?: StringNullableFilter<"UserPhoto"> | string | null
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    isPrimary?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPhotoCountOrderByAggregateInput
    _max?: UserPhotoMaxOrderByAggregateInput
    _min?: UserPhotoMinOrderByAggregateInput
  }

  export type UserPhotoScalarWhereWithAggregatesInput = {
    AND?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    OR?: UserPhotoScalarWhereWithAggregatesInput[]
    NOT?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPhoto"> | string
    userId?: StringWithAggregatesFilter<"UserPhoto"> | string
    imageUrl?: StringWithAggregatesFilter<"UserPhoto"> | string
    isPrimary?: BoolWithAggregatesFilter<"UserPhoto"> | boolean
    metadata?: StringNullableWithAggregatesFilter<"UserPhoto"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
  }

  export type WardrobeItemWhereInput = {
    AND?: WardrobeItemWhereInput | WardrobeItemWhereInput[]
    OR?: WardrobeItemWhereInput[]
    NOT?: WardrobeItemWhereInput | WardrobeItemWhereInput[]
    id?: StringFilter<"WardrobeItem"> | string
    userId?: StringFilter<"WardrobeItem"> | string
    imageUrl?: StringFilter<"WardrobeItem"> | string
    cutoutImageUrl?: StringNullableFilter<"WardrobeItem"> | string | null
    cutoutStatus?: StringFilter<"WardrobeItem"> | string
    cutoutError?: StringNullableFilter<"WardrobeItem"> | string | null
    category?: StringFilter<"WardrobeItem"> | string
    colorFamily?: StringFilter<"WardrobeItem"> | string
    colorHex?: StringNullableFilter<"WardrobeItem"> | string | null
    styleTags?: StringFilter<"WardrobeItem"> | string
    seasonTags?: StringFilter<"WardrobeItem"> | string
    fitTag?: StringFilter<"WardrobeItem"> | string
    extraTags?: StringNullableFilter<"WardrobeItem"> | string | null
    confidence?: StringFilter<"WardrobeItem"> | string
    rawAiJson?: StringNullableFilter<"WardrobeItem"> | string | null
    userNotes?: StringNullableFilter<"WardrobeItem"> | string | null
    productType?: StringNullableFilter<"WardrobeItem"> | string | null
    color?: StringNullableFilter<"WardrobeItem"> | string | null
    tags?: StringNullableFilter<"WardrobeItem"> | string | null
    brand?: StringNullableFilter<"WardrobeItem"> | string | null
    size?: StringNullableFilter<"WardrobeItem"> | string | null
    createdAt?: DateTimeFilter<"WardrobeItem"> | Date | string
    updatedAt?: DateTimeFilter<"WardrobeItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfitItems?: OutfitItemListRelationFilter
  }

  export type WardrobeItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    cutoutImageUrl?: SortOrderInput | SortOrder
    cutoutStatus?: SortOrder
    cutoutError?: SortOrderInput | SortOrder
    category?: SortOrder
    colorFamily?: SortOrder
    colorHex?: SortOrderInput | SortOrder
    styleTags?: SortOrder
    seasonTags?: SortOrder
    fitTag?: SortOrder
    extraTags?: SortOrderInput | SortOrder
    confidence?: SortOrder
    rawAiJson?: SortOrderInput | SortOrder
    userNotes?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    outfitItems?: OutfitItemOrderByRelationAggregateInput
  }

  export type WardrobeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WardrobeItemWhereInput | WardrobeItemWhereInput[]
    OR?: WardrobeItemWhereInput[]
    NOT?: WardrobeItemWhereInput | WardrobeItemWhereInput[]
    userId?: StringFilter<"WardrobeItem"> | string
    imageUrl?: StringFilter<"WardrobeItem"> | string
    cutoutImageUrl?: StringNullableFilter<"WardrobeItem"> | string | null
    cutoutStatus?: StringFilter<"WardrobeItem"> | string
    cutoutError?: StringNullableFilter<"WardrobeItem"> | string | null
    category?: StringFilter<"WardrobeItem"> | string
    colorFamily?: StringFilter<"WardrobeItem"> | string
    colorHex?: StringNullableFilter<"WardrobeItem"> | string | null
    styleTags?: StringFilter<"WardrobeItem"> | string
    seasonTags?: StringFilter<"WardrobeItem"> | string
    fitTag?: StringFilter<"WardrobeItem"> | string
    extraTags?: StringNullableFilter<"WardrobeItem"> | string | null
    confidence?: StringFilter<"WardrobeItem"> | string
    rawAiJson?: StringNullableFilter<"WardrobeItem"> | string | null
    userNotes?: StringNullableFilter<"WardrobeItem"> | string | null
    productType?: StringNullableFilter<"WardrobeItem"> | string | null
    color?: StringNullableFilter<"WardrobeItem"> | string | null
    tags?: StringNullableFilter<"WardrobeItem"> | string | null
    brand?: StringNullableFilter<"WardrobeItem"> | string | null
    size?: StringNullableFilter<"WardrobeItem"> | string | null
    createdAt?: DateTimeFilter<"WardrobeItem"> | Date | string
    updatedAt?: DateTimeFilter<"WardrobeItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfitItems?: OutfitItemListRelationFilter
  }, "id">

  export type WardrobeItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    cutoutImageUrl?: SortOrderInput | SortOrder
    cutoutStatus?: SortOrder
    cutoutError?: SortOrderInput | SortOrder
    category?: SortOrder
    colorFamily?: SortOrder
    colorHex?: SortOrderInput | SortOrder
    styleTags?: SortOrder
    seasonTags?: SortOrder
    fitTag?: SortOrder
    extraTags?: SortOrderInput | SortOrder
    confidence?: SortOrder
    rawAiJson?: SortOrderInput | SortOrder
    userNotes?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WardrobeItemCountOrderByAggregateInput
    _max?: WardrobeItemMaxOrderByAggregateInput
    _min?: WardrobeItemMinOrderByAggregateInput
  }

  export type WardrobeItemScalarWhereWithAggregatesInput = {
    AND?: WardrobeItemScalarWhereWithAggregatesInput | WardrobeItemScalarWhereWithAggregatesInput[]
    OR?: WardrobeItemScalarWhereWithAggregatesInput[]
    NOT?: WardrobeItemScalarWhereWithAggregatesInput | WardrobeItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WardrobeItem"> | string
    userId?: StringWithAggregatesFilter<"WardrobeItem"> | string
    imageUrl?: StringWithAggregatesFilter<"WardrobeItem"> | string
    cutoutImageUrl?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    cutoutStatus?: StringWithAggregatesFilter<"WardrobeItem"> | string
    cutoutError?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    category?: StringWithAggregatesFilter<"WardrobeItem"> | string
    colorFamily?: StringWithAggregatesFilter<"WardrobeItem"> | string
    colorHex?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    styleTags?: StringWithAggregatesFilter<"WardrobeItem"> | string
    seasonTags?: StringWithAggregatesFilter<"WardrobeItem"> | string
    fitTag?: StringWithAggregatesFilter<"WardrobeItem"> | string
    extraTags?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    confidence?: StringWithAggregatesFilter<"WardrobeItem"> | string
    rawAiJson?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    userNotes?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    productType?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    color?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    tags?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    brand?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    size?: StringNullableWithAggregatesFilter<"WardrobeItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WardrobeItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WardrobeItem"> | Date | string
  }

  export type OutfitWhereInput = {
    AND?: OutfitWhereInput | OutfitWhereInput[]
    OR?: OutfitWhereInput[]
    NOT?: OutfitWhereInput | OutfitWhereInput[]
    id?: StringFilter<"Outfit"> | string
    userId?: StringFilter<"Outfit"> | string
    weekStartDate?: DateTimeFilter<"Outfit"> | Date | string
    dayIndex?: IntFilter<"Outfit"> | number
    status?: StringFilter<"Outfit"> | string
    imageUrl?: StringNullableFilter<"Outfit"> | string | null
    promptVersion?: StringNullableFilter<"Outfit"> | string | null
    weather?: StringNullableFilter<"Outfit"> | string | null
    category?: StringNullableFilter<"Outfit"> | string | null
    createdAt?: DateTimeFilter<"Outfit"> | Date | string
    updatedAt?: DateTimeFilter<"Outfit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfitItems?: OutfitItemListRelationFilter
    renderJobs?: RenderJobListRelationFilter
  }

  export type OutfitOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    dayIndex?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    promptVersion?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    outfitItems?: OutfitItemOrderByRelationAggregateInput
    renderJobs?: RenderJobOrderByRelationAggregateInput
  }

  export type OutfitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_weekStartDate_dayIndex?: OutfitUserIdWeekStartDateDayIndexCompoundUniqueInput
    AND?: OutfitWhereInput | OutfitWhereInput[]
    OR?: OutfitWhereInput[]
    NOT?: OutfitWhereInput | OutfitWhereInput[]
    userId?: StringFilter<"Outfit"> | string
    weekStartDate?: DateTimeFilter<"Outfit"> | Date | string
    dayIndex?: IntFilter<"Outfit"> | number
    status?: StringFilter<"Outfit"> | string
    imageUrl?: StringNullableFilter<"Outfit"> | string | null
    promptVersion?: StringNullableFilter<"Outfit"> | string | null
    weather?: StringNullableFilter<"Outfit"> | string | null
    category?: StringNullableFilter<"Outfit"> | string | null
    createdAt?: DateTimeFilter<"Outfit"> | Date | string
    updatedAt?: DateTimeFilter<"Outfit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfitItems?: OutfitItemListRelationFilter
    renderJobs?: RenderJobListRelationFilter
  }, "id" | "userId_weekStartDate_dayIndex">

  export type OutfitOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    dayIndex?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    promptVersion?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutfitCountOrderByAggregateInput
    _avg?: OutfitAvgOrderByAggregateInput
    _max?: OutfitMaxOrderByAggregateInput
    _min?: OutfitMinOrderByAggregateInput
    _sum?: OutfitSumOrderByAggregateInput
  }

  export type OutfitScalarWhereWithAggregatesInput = {
    AND?: OutfitScalarWhereWithAggregatesInput | OutfitScalarWhereWithAggregatesInput[]
    OR?: OutfitScalarWhereWithAggregatesInput[]
    NOT?: OutfitScalarWhereWithAggregatesInput | OutfitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Outfit"> | string
    userId?: StringWithAggregatesFilter<"Outfit"> | string
    weekStartDate?: DateTimeWithAggregatesFilter<"Outfit"> | Date | string
    dayIndex?: IntWithAggregatesFilter<"Outfit"> | number
    status?: StringWithAggregatesFilter<"Outfit"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    promptVersion?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    weather?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    category?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Outfit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Outfit"> | Date | string
  }

  export type OutfitItemWhereInput = {
    AND?: OutfitItemWhereInput | OutfitItemWhereInput[]
    OR?: OutfitItemWhereInput[]
    NOT?: OutfitItemWhereInput | OutfitItemWhereInput[]
    outfitId?: StringFilter<"OutfitItem"> | string
    wardrobeItemId?: StringFilter<"OutfitItem"> | string
    outfit?: XOR<OutfitRelationFilter, OutfitWhereInput>
    wardrobeItem?: XOR<WardrobeItemRelationFilter, WardrobeItemWhereInput>
  }

  export type OutfitItemOrderByWithRelationInput = {
    outfitId?: SortOrder
    wardrobeItemId?: SortOrder
    outfit?: OutfitOrderByWithRelationInput
    wardrobeItem?: WardrobeItemOrderByWithRelationInput
  }

  export type OutfitItemWhereUniqueInput = Prisma.AtLeast<{
    outfitId_wardrobeItemId?: OutfitItemOutfitIdWardrobeItemIdCompoundUniqueInput
    AND?: OutfitItemWhereInput | OutfitItemWhereInput[]
    OR?: OutfitItemWhereInput[]
    NOT?: OutfitItemWhereInput | OutfitItemWhereInput[]
    outfitId?: StringFilter<"OutfitItem"> | string
    wardrobeItemId?: StringFilter<"OutfitItem"> | string
    outfit?: XOR<OutfitRelationFilter, OutfitWhereInput>
    wardrobeItem?: XOR<WardrobeItemRelationFilter, WardrobeItemWhereInput>
  }, "outfitId_wardrobeItemId">

  export type OutfitItemOrderByWithAggregationInput = {
    outfitId?: SortOrder
    wardrobeItemId?: SortOrder
    _count?: OutfitItemCountOrderByAggregateInput
    _max?: OutfitItemMaxOrderByAggregateInput
    _min?: OutfitItemMinOrderByAggregateInput
  }

  export type OutfitItemScalarWhereWithAggregatesInput = {
    AND?: OutfitItemScalarWhereWithAggregatesInput | OutfitItemScalarWhereWithAggregatesInput[]
    OR?: OutfitItemScalarWhereWithAggregatesInput[]
    NOT?: OutfitItemScalarWhereWithAggregatesInput | OutfitItemScalarWhereWithAggregatesInput[]
    outfitId?: StringWithAggregatesFilter<"OutfitItem"> | string
    wardrobeItemId?: StringWithAggregatesFilter<"OutfitItem"> | string
  }

  export type RenderJobWhereInput = {
    AND?: RenderJobWhereInput | RenderJobWhereInput[]
    OR?: RenderJobWhereInput[]
    NOT?: RenderJobWhereInput | RenderJobWhereInput[]
    id?: StringFilter<"RenderJob"> | string
    userId?: StringFilter<"RenderJob"> | string
    outfitId?: StringNullableFilter<"RenderJob"> | string | null
    status?: StringFilter<"RenderJob"> | string
    attempts?: IntFilter<"RenderJob"> | number
    error?: StringNullableFilter<"RenderJob"> | string | null
    startedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    createdAt?: DateTimeFilter<"RenderJob"> | Date | string
    updatedAt?: DateTimeFilter<"RenderJob"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfit?: XOR<OutfitNullableRelationFilter, OutfitWhereInput> | null
  }

  export type RenderJobOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    outfitId?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    outfit?: OutfitOrderByWithRelationInput
  }

  export type RenderJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RenderJobWhereInput | RenderJobWhereInput[]
    OR?: RenderJobWhereInput[]
    NOT?: RenderJobWhereInput | RenderJobWhereInput[]
    userId?: StringFilter<"RenderJob"> | string
    outfitId?: StringNullableFilter<"RenderJob"> | string | null
    status?: StringFilter<"RenderJob"> | string
    attempts?: IntFilter<"RenderJob"> | number
    error?: StringNullableFilter<"RenderJob"> | string | null
    startedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    createdAt?: DateTimeFilter<"RenderJob"> | Date | string
    updatedAt?: DateTimeFilter<"RenderJob"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    outfit?: XOR<OutfitNullableRelationFilter, OutfitWhereInput> | null
  }, "id">

  export type RenderJobOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    outfitId?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RenderJobCountOrderByAggregateInput
    _avg?: RenderJobAvgOrderByAggregateInput
    _max?: RenderJobMaxOrderByAggregateInput
    _min?: RenderJobMinOrderByAggregateInput
    _sum?: RenderJobSumOrderByAggregateInput
  }

  export type RenderJobScalarWhereWithAggregatesInput = {
    AND?: RenderJobScalarWhereWithAggregatesInput | RenderJobScalarWhereWithAggregatesInput[]
    OR?: RenderJobScalarWhereWithAggregatesInput[]
    NOT?: RenderJobScalarWhereWithAggregatesInput | RenderJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RenderJob"> | string
    userId?: StringWithAggregatesFilter<"RenderJob"> | string
    outfitId?: StringNullableWithAggregatesFilter<"RenderJob"> | string | null
    status?: StringWithAggregatesFilter<"RenderJob"> | string
    attempts?: IntWithAggregatesFilter<"RenderJob"> | number
    error?: StringNullableWithAggregatesFilter<"RenderJob"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"RenderJob"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"RenderJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RenderJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RenderJob"> | Date | string
  }

  export type CreditsLedgerWhereInput = {
    AND?: CreditsLedgerWhereInput | CreditsLedgerWhereInput[]
    OR?: CreditsLedgerWhereInput[]
    NOT?: CreditsLedgerWhereInput | CreditsLedgerWhereInput[]
    id?: StringFilter<"CreditsLedger"> | string
    userId?: StringFilter<"CreditsLedger"> | string
    delta?: IntFilter<"CreditsLedger"> | number
    reason?: StringFilter<"CreditsLedger"> | string
    refId?: StringNullableFilter<"CreditsLedger"> | string | null
    createdAt?: DateTimeFilter<"CreditsLedger"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CreditsLedgerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    delta?: SortOrder
    reason?: SortOrder
    refId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CreditsLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditsLedgerWhereInput | CreditsLedgerWhereInput[]
    OR?: CreditsLedgerWhereInput[]
    NOT?: CreditsLedgerWhereInput | CreditsLedgerWhereInput[]
    userId?: StringFilter<"CreditsLedger"> | string
    delta?: IntFilter<"CreditsLedger"> | number
    reason?: StringFilter<"CreditsLedger"> | string
    refId?: StringNullableFilter<"CreditsLedger"> | string | null
    createdAt?: DateTimeFilter<"CreditsLedger"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CreditsLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    delta?: SortOrder
    reason?: SortOrder
    refId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CreditsLedgerCountOrderByAggregateInput
    _avg?: CreditsLedgerAvgOrderByAggregateInput
    _max?: CreditsLedgerMaxOrderByAggregateInput
    _min?: CreditsLedgerMinOrderByAggregateInput
    _sum?: CreditsLedgerSumOrderByAggregateInput
  }

  export type CreditsLedgerScalarWhereWithAggregatesInput = {
    AND?: CreditsLedgerScalarWhereWithAggregatesInput | CreditsLedgerScalarWhereWithAggregatesInput[]
    OR?: CreditsLedgerScalarWhereWithAggregatesInput[]
    NOT?: CreditsLedgerScalarWhereWithAggregatesInput | CreditsLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditsLedger"> | string
    userId?: StringWithAggregatesFilter<"CreditsLedger"> | string
    delta?: IntWithAggregatesFilter<"CreditsLedger"> | number
    reason?: StringWithAggregatesFilter<"CreditsLedger"> | string
    refId?: StringNullableWithAggregatesFilter<"CreditsLedger"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CreditsLedger"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    platform?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    appleOriginalTransactionId?: StringNullableFilter<"Subscription"> | string | null
    appleProductId?: StringNullableFilter<"Subscription"> | string | null
    appleReceiptData?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    purchases?: PurchaseListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    platform?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    appleOriginalTransactionId?: SortOrderInput | SortOrder
    appleProductId?: SortOrderInput | SortOrder
    appleReceiptData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    purchases?: PurchaseOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    platform?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    appleOriginalTransactionId?: StringNullableFilter<"Subscription"> | string | null
    appleProductId?: StringNullableFilter<"Subscription"> | string | null
    appleReceiptData?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    purchases?: PurchaseListRelationFilter
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    platform?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    appleOriginalTransactionId?: SortOrderInput | SortOrder
    appleProductId?: SortOrderInput | SortOrder
    appleReceiptData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    platform?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    appleOriginalTransactionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    appleProductId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    appleReceiptData?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    subscriptionId?: StringNullableFilter<"Purchase"> | string | null
    platform?: StringFilter<"Purchase"> | string
    externalId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    plan?: StringFilter<"Purchase"> | string
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntNullableFilter<"Purchase"> | number | null
    currency?: StringNullableFilter<"Purchase"> | string | null
    periodStart?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    metadata?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    productId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    periodStart?: SortOrderInput | SortOrder
    periodEnd?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_platform_externalId?: PurchaseUserIdPlatformExternalIdCompoundUniqueInput
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    userId?: StringFilter<"Purchase"> | string
    subscriptionId?: StringNullableFilter<"Purchase"> | string | null
    platform?: StringFilter<"Purchase"> | string
    externalId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    plan?: StringFilter<"Purchase"> | string
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntNullableFilter<"Purchase"> | number | null
    currency?: StringNullableFilter<"Purchase"> | string | null
    periodStart?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    metadata?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "userId_platform_externalId">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    productId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    periodStart?: SortOrderInput | SortOrder
    periodEnd?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    userId?: StringWithAggregatesFilter<"Purchase"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    platform?: StringWithAggregatesFilter<"Purchase"> | string
    externalId?: StringWithAggregatesFilter<"Purchase"> | string
    productId?: StringWithAggregatesFilter<"Purchase"> | string
    plan?: StringWithAggregatesFilter<"Purchase"> | string
    status?: StringWithAggregatesFilter<"Purchase"> | string
    amountCents?: IntNullableWithAggregatesFilter<"Purchase"> | number | null
    currency?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    periodStart?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    periodEnd?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    metadata?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type UsageWhereInput = {
    AND?: UsageWhereInput | UsageWhereInput[]
    OR?: UsageWhereInput[]
    NOT?: UsageWhereInput | UsageWhereInput[]
    id?: StringFilter<"Usage"> | string
    userId?: StringFilter<"Usage"> | string
    month?: StringFilter<"Usage"> | string
    aiGenerationsCount?: IntFilter<"Usage"> | number
    virtualTryonCount?: IntFilter<"Usage"> | number
    weeklyGenerationCount?: IntFilter<"Usage"> | number
    createdAt?: DateTimeFilter<"Usage"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_month?: UsageUserIdMonthCompoundUniqueInput
    AND?: UsageWhereInput | UsageWhereInput[]
    OR?: UsageWhereInput[]
    NOT?: UsageWhereInput | UsageWhereInput[]
    userId?: StringFilter<"Usage"> | string
    month?: StringFilter<"Usage"> | string
    aiGenerationsCount?: IntFilter<"Usage"> | number
    virtualTryonCount?: IntFilter<"Usage"> | number
    weeklyGenerationCount?: IntFilter<"Usage"> | number
    createdAt?: DateTimeFilter<"Usage"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_month">

  export type UsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
    createdAt?: SortOrder
    _count?: UsageCountOrderByAggregateInput
    _avg?: UsageAvgOrderByAggregateInput
    _max?: UsageMaxOrderByAggregateInput
    _min?: UsageMinOrderByAggregateInput
    _sum?: UsageSumOrderByAggregateInput
  }

  export type UsageScalarWhereWithAggregatesInput = {
    AND?: UsageScalarWhereWithAggregatesInput | UsageScalarWhereWithAggregatesInput[]
    OR?: UsageScalarWhereWithAggregatesInput[]
    NOT?: UsageScalarWhereWithAggregatesInput | UsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usage"> | string
    userId?: StringWithAggregatesFilter<"Usage"> | string
    month?: StringWithAggregatesFilter<"Usage"> | string
    aiGenerationsCount?: IntWithAggregatesFilter<"Usage"> | number
    virtualTryonCount?: IntWithAggregatesFilter<"Usage"> | number
    weeklyGenerationCount?: IntWithAggregatesFilter<"Usage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Usage"> | Date | string
  }

  export type EventAnalyticsWhereInput = {
    AND?: EventAnalyticsWhereInput | EventAnalyticsWhereInput[]
    OR?: EventAnalyticsWhereInput[]
    NOT?: EventAnalyticsWhereInput | EventAnalyticsWhereInput[]
    id?: StringFilter<"EventAnalytics"> | string
    userId?: StringNullableFilter<"EventAnalytics"> | string | null
    eventName?: StringFilter<"EventAnalytics"> | string
    props?: StringNullableFilter<"EventAnalytics"> | string | null
    createdAt?: DateTimeFilter<"EventAnalytics"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EventAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    props?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EventAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventAnalyticsWhereInput | EventAnalyticsWhereInput[]
    OR?: EventAnalyticsWhereInput[]
    NOT?: EventAnalyticsWhereInput | EventAnalyticsWhereInput[]
    userId?: StringNullableFilter<"EventAnalytics"> | string | null
    eventName?: StringFilter<"EventAnalytics"> | string
    props?: StringNullableFilter<"EventAnalytics"> | string | null
    createdAt?: DateTimeFilter<"EventAnalytics"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type EventAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    props?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventAnalyticsCountOrderByAggregateInput
    _max?: EventAnalyticsMaxOrderByAggregateInput
    _min?: EventAnalyticsMinOrderByAggregateInput
  }

  export type EventAnalyticsScalarWhereWithAggregatesInput = {
    AND?: EventAnalyticsScalarWhereWithAggregatesInput | EventAnalyticsScalarWhereWithAggregatesInput[]
    OR?: EventAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: EventAnalyticsScalarWhereWithAggregatesInput | EventAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventAnalytics"> | string
    userId?: StringNullableWithAggregatesFilter<"EventAnalytics"> | string | null
    eventName?: StringWithAggregatesFilter<"EventAnalytics"> | string
    props?: StringNullableWithAggregatesFilter<"EventAnalytics"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventAnalytics"> | Date | string
  }

  export type HelpCenterConversationWhereInput = {
    AND?: HelpCenterConversationWhereInput | HelpCenterConversationWhereInput[]
    OR?: HelpCenterConversationWhereInput[]
    NOT?: HelpCenterConversationWhereInput | HelpCenterConversationWhereInput[]
    id?: StringFilter<"HelpCenterConversation"> | string
    userId?: StringFilter<"HelpCenterConversation"> | string
    status?: StringFilter<"HelpCenterConversation"> | string
    createdAt?: DateTimeFilter<"HelpCenterConversation"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCenterConversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: HelpCenterMessageListRelationFilter
  }

  export type HelpCenterConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: HelpCenterMessageOrderByRelationAggregateInput
  }

  export type HelpCenterConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: HelpCenterConversationWhereInput | HelpCenterConversationWhereInput[]
    OR?: HelpCenterConversationWhereInput[]
    NOT?: HelpCenterConversationWhereInput | HelpCenterConversationWhereInput[]
    status?: StringFilter<"HelpCenterConversation"> | string
    createdAt?: DateTimeFilter<"HelpCenterConversation"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCenterConversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: HelpCenterMessageListRelationFilter
  }, "id" | "userId">

  export type HelpCenterConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpCenterConversationCountOrderByAggregateInput
    _max?: HelpCenterConversationMaxOrderByAggregateInput
    _min?: HelpCenterConversationMinOrderByAggregateInput
  }

  export type HelpCenterConversationScalarWhereWithAggregatesInput = {
    AND?: HelpCenterConversationScalarWhereWithAggregatesInput | HelpCenterConversationScalarWhereWithAggregatesInput[]
    OR?: HelpCenterConversationScalarWhereWithAggregatesInput[]
    NOT?: HelpCenterConversationScalarWhereWithAggregatesInput | HelpCenterConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpCenterConversation"> | string
    userId?: StringWithAggregatesFilter<"HelpCenterConversation"> | string
    status?: StringWithAggregatesFilter<"HelpCenterConversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HelpCenterConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpCenterConversation"> | Date | string
  }

  export type HelpCenterMessageWhereInput = {
    AND?: HelpCenterMessageWhereInput | HelpCenterMessageWhereInput[]
    OR?: HelpCenterMessageWhereInput[]
    NOT?: HelpCenterMessageWhereInput | HelpCenterMessageWhereInput[]
    id?: StringFilter<"HelpCenterMessage"> | string
    conversationId?: StringFilter<"HelpCenterMessage"> | string
    sender?: StringFilter<"HelpCenterMessage"> | string
    text?: StringFilter<"HelpCenterMessage"> | string
    createdAt?: DateTimeFilter<"HelpCenterMessage"> | Date | string
    conversation?: XOR<HelpCenterConversationRelationFilter, HelpCenterConversationWhereInput>
  }

  export type HelpCenterMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    conversation?: HelpCenterConversationOrderByWithRelationInput
  }

  export type HelpCenterMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpCenterMessageWhereInput | HelpCenterMessageWhereInput[]
    OR?: HelpCenterMessageWhereInput[]
    NOT?: HelpCenterMessageWhereInput | HelpCenterMessageWhereInput[]
    conversationId?: StringFilter<"HelpCenterMessage"> | string
    sender?: StringFilter<"HelpCenterMessage"> | string
    text?: StringFilter<"HelpCenterMessage"> | string
    createdAt?: DateTimeFilter<"HelpCenterMessage"> | Date | string
    conversation?: XOR<HelpCenterConversationRelationFilter, HelpCenterConversationWhereInput>
  }, "id">

  export type HelpCenterMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: HelpCenterMessageCountOrderByAggregateInput
    _max?: HelpCenterMessageMaxOrderByAggregateInput
    _min?: HelpCenterMessageMinOrderByAggregateInput
  }

  export type HelpCenterMessageScalarWhereWithAggregatesInput = {
    AND?: HelpCenterMessageScalarWhereWithAggregatesInput | HelpCenterMessageScalarWhereWithAggregatesInput[]
    OR?: HelpCenterMessageScalarWhereWithAggregatesInput[]
    NOT?: HelpCenterMessageScalarWhereWithAggregatesInput | HelpCenterMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpCenterMessage"> | string
    conversationId?: StringWithAggregatesFilter<"HelpCenterMessage"> | string
    sender?: StringWithAggregatesFilter<"HelpCenterMessage"> | string
    text?: StringWithAggregatesFilter<"HelpCenterMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HelpCenterMessage"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    enabled?: BoolFilter<"NotificationSettings"> | boolean
    expoPushToken?: StringNullableFilter<"NotificationSettings"> | string | null
    latitude?: FloatNullableFilter<"NotificationSettings"> | number | null
    longitude?: FloatNullableFilter<"NotificationSettings"> | number | null
    timezone?: StringFilter<"NotificationSettings"> | string
    notifyAtLocalTime?: StringFilter<"NotificationSettings"> | string
    coldThresholdC?: FloatFilter<"NotificationSettings"> | number
    hotThresholdC?: FloatFilter<"NotificationSettings"> | number
    tempChangeThresholdC?: FloatFilter<"NotificationSettings"> | number
    notifyOnWeatherChange?: BoolFilter<"NotificationSettings"> | boolean
    minHoursBetweenNotifs?: IntFilter<"NotificationSettings"> | number
    lastNotifiedAt?: DateTimeNullableFilter<"NotificationSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    enabled?: SortOrder
    expoPushToken?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    timezone?: SortOrder
    notifyAtLocalTime?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    notifyOnWeatherChange?: SortOrder
    minHoursBetweenNotifs?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    enabled?: BoolFilter<"NotificationSettings"> | boolean
    expoPushToken?: StringNullableFilter<"NotificationSettings"> | string | null
    latitude?: FloatNullableFilter<"NotificationSettings"> | number | null
    longitude?: FloatNullableFilter<"NotificationSettings"> | number | null
    timezone?: StringFilter<"NotificationSettings"> | string
    notifyAtLocalTime?: StringFilter<"NotificationSettings"> | string
    coldThresholdC?: FloatFilter<"NotificationSettings"> | number
    hotThresholdC?: FloatFilter<"NotificationSettings"> | number
    tempChangeThresholdC?: FloatFilter<"NotificationSettings"> | number
    notifyOnWeatherChange?: BoolFilter<"NotificationSettings"> | boolean
    minHoursBetweenNotifs?: IntFilter<"NotificationSettings"> | number
    lastNotifiedAt?: DateTimeNullableFilter<"NotificationSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    enabled?: SortOrder
    expoPushToken?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    timezone?: SortOrder
    notifyAtLocalTime?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    notifyOnWeatherChange?: SortOrder
    minHoursBetweenNotifs?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _avg?: NotificationSettingsAvgOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
    _sum?: NotificationSettingsSumOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    userId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    enabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    expoPushToken?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"NotificationSettings"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"NotificationSettings"> | number | null
    timezone?: StringWithAggregatesFilter<"NotificationSettings"> | string
    notifyAtLocalTime?: StringWithAggregatesFilter<"NotificationSettings"> | string
    coldThresholdC?: FloatWithAggregatesFilter<"NotificationSettings"> | number
    hotThresholdC?: FloatWithAggregatesFilter<"NotificationSettings"> | number
    tempChangeThresholdC?: FloatWithAggregatesFilter<"NotificationSettings"> | number
    notifyOnWeatherChange?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    minHoursBetweenNotifs?: IntWithAggregatesFilter<"NotificationSettings"> | number
    lastNotifiedAt?: DateTimeNullableWithAggregatesFilter<"NotificationSettings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoCreateInput = {
    id?: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPhotosInput
  }

  export type UserPhotoUncheckedCreateInput = {
    id?: string
    userId: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type UserPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoCreateManyInput = {
    id?: string
    userId: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardrobeItemCreateInput = {
    id?: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWardrobeItemsInput
    outfitItems?: OutfitItemCreateNestedManyWithoutWardrobeItemInput
  }

  export type WardrobeItemUncheckedCreateInput = {
    id?: string
    userId: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemUncheckedCreateNestedManyWithoutWardrobeItemInput
  }

  export type WardrobeItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWardrobeItemsNestedInput
    outfitItems?: OutfitItemUpdateManyWithoutWardrobeItemNestedInput
  }

  export type WardrobeItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUncheckedUpdateManyWithoutWardrobeItemNestedInput
  }

  export type WardrobeItemCreateManyInput = {
    id?: string
    userId: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardrobeItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardrobeItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitCreateInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    outfitItems?: OutfitItemCreateNestedManyWithoutOutfitInput
    renderJobs?: RenderJobCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemUncheckedCreateNestedManyWithoutOutfitInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    outfitItems?: OutfitItemUpdateManyWithoutOutfitNestedInput
    renderJobs?: RenderJobUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUncheckedUpdateManyWithoutOutfitNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitCreateManyInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutfitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitItemCreateInput = {
    outfit: OutfitCreateNestedOneWithoutOutfitItemsInput
    wardrobeItem: WardrobeItemCreateNestedOneWithoutOutfitItemsInput
  }

  export type OutfitItemUncheckedCreateInput = {
    outfitId: string
    wardrobeItemId: string
  }

  export type OutfitItemUpdateInput = {
    outfit?: OutfitUpdateOneRequiredWithoutOutfitItemsNestedInput
    wardrobeItem?: WardrobeItemUpdateOneRequiredWithoutOutfitItemsNestedInput
  }

  export type OutfitItemUncheckedUpdateInput = {
    outfitId?: StringFieldUpdateOperationsInput | string
    wardrobeItemId?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitItemCreateManyInput = {
    outfitId: string
    wardrobeItemId: string
  }

  export type OutfitItemUpdateManyMutationInput = {

  }

  export type OutfitItemUncheckedUpdateManyInput = {
    outfitId?: StringFieldUpdateOperationsInput | string
    wardrobeItemId?: StringFieldUpdateOperationsInput | string
  }

  export type RenderJobCreateInput = {
    id?: string
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRenderJobsInput
    outfit?: OutfitCreateNestedOneWithoutRenderJobsInput
  }

  export type RenderJobUncheckedCreateInput = {
    id?: string
    userId: string
    outfitId?: string | null
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RenderJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRenderJobsNestedInput
    outfit?: OutfitUpdateOneWithoutRenderJobsNestedInput
  }

  export type RenderJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outfitId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RenderJobCreateManyInput = {
    id?: string
    userId: string
    outfitId?: string | null
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RenderJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RenderJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outfitId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerCreateInput = {
    id?: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCreditsLedgerInput
  }

  export type CreditsLedgerUncheckedCreateInput = {
    id?: string
    userId: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
  }

  export type CreditsLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreditsLedgerNestedInput
  }

  export type CreditsLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerCreateManyInput = {
    id?: string
    userId: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
  }

  export type CreditsLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    purchases?: PurchaseCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    purchases?: PurchaseUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    subscription?: SubscriptionCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    subscription?: SubscriptionUpdateOneWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCreateInput = {
    id?: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUsageRecordsInput
  }

  export type UsageUncheckedCreateInput = {
    id?: string
    userId: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
  }

  export type UsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type UsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCreateManyInput = {
    id?: string
    userId: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
  }

  export type UsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsCreateInput = {
    id?: string
    eventName: string
    props?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutEventsAnalyticsInput
  }

  export type EventAnalyticsUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventName: string
    props?: string | null
    createdAt?: Date | string
  }

  export type EventAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEventsAnalyticsNestedInput
  }

  export type EventAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsCreateManyInput = {
    id?: string
    userId?: string | null
    eventName: string
    props?: string | null
    createdAt?: Date | string
  }

  export type EventAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterConversationCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHelpCenterConversationInput
    messages?: HelpCenterMessageCreateNestedManyWithoutConversationInput
  }

  export type HelpCenterConversationUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: HelpCenterMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type HelpCenterConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHelpCenterConversationNestedInput
    messages?: HelpCenterMessageUpdateManyWithoutConversationNestedInput
  }

  export type HelpCenterConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: HelpCenterMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type HelpCenterConversationCreateManyInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCenterConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageCreateInput = {
    id?: string
    sender: string
    text: string
    createdAt?: Date | string
    conversation: HelpCenterConversationCreateNestedOneWithoutMessagesInput
  }

  export type HelpCenterMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    sender: string
    text: string
    createdAt?: Date | string
  }

  export type HelpCenterMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: HelpCenterConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type HelpCenterMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageCreateManyInput = {
    id?: string
    conversationId: string
    sender: string
    text: string
    createdAt?: Date | string
  }

  export type HelpCenterMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    enabled?: boolean
    expoPushToken?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    notifyAtLocalTime?: string
    coldThresholdC?: number
    hotThresholdC?: number
    tempChangeThresholdC?: number
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: number
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    enabled?: boolean
    expoPushToken?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    notifyAtLocalTime?: string
    coldThresholdC?: number
    hotThresholdC?: number
    tempChangeThresholdC?: number
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: number
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    userId: string
    enabled?: boolean
    expoPushToken?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    notifyAtLocalTime?: string
    coldThresholdC?: number
    hotThresholdC?: number
    tempChangeThresholdC?: number
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: number
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserPhotoListRelationFilter = {
    every?: UserPhotoWhereInput
    some?: UserPhotoWhereInput
    none?: UserPhotoWhereInput
  }

  export type WardrobeItemListRelationFilter = {
    every?: WardrobeItemWhereInput
    some?: WardrobeItemWhereInput
    none?: WardrobeItemWhereInput
  }

  export type OutfitListRelationFilter = {
    every?: OutfitWhereInput
    some?: OutfitWhereInput
    none?: OutfitWhereInput
  }

  export type RenderJobListRelationFilter = {
    every?: RenderJobWhereInput
    some?: RenderJobWhereInput
    none?: RenderJobWhereInput
  }

  export type CreditsLedgerListRelationFilter = {
    every?: CreditsLedgerWhereInput
    some?: CreditsLedgerWhereInput
    none?: CreditsLedgerWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type UsageListRelationFilter = {
    every?: UsageWhereInput
    some?: UsageWhereInput
    none?: UsageWhereInput
  }

  export type EventAnalyticsListRelationFilter = {
    every?: EventAnalyticsWhereInput
    some?: EventAnalyticsWhereInput
    none?: EventAnalyticsWhereInput
  }

  export type NotificationSettingsNullableRelationFilter = {
    is?: NotificationSettingsWhereInput | null
    isNot?: NotificationSettingsWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type HelpCenterConversationNullableRelationFilter = {
    is?: HelpCenterConversationWhereInput | null
    isNot?: HelpCenterConversationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardrobeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutfitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RenderJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditsLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatarBaseImageUrl?: SortOrder
    onboardingStatus?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    heightCm?: SortOrder
    emailVerificationCode?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerifiedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    age?: SortOrder
    heightCm?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatarBaseImageUrl?: SortOrder
    onboardingStatus?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    heightCm?: SortOrder
    emailVerificationCode?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerifiedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatarBaseImageUrl?: SortOrder
    onboardingStatus?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    heightCm?: SortOrder
    emailVerificationCode?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerifiedAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    age?: SortOrder
    heightCm?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    isPrimary?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    isPrimary?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    isPrimary?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OutfitItemListRelationFilter = {
    every?: OutfitItemWhereInput
    some?: OutfitItemWhereInput
    none?: OutfitItemWhereInput
  }

  export type OutfitItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardrobeItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    cutoutImageUrl?: SortOrder
    cutoutStatus?: SortOrder
    cutoutError?: SortOrder
    category?: SortOrder
    colorFamily?: SortOrder
    colorHex?: SortOrder
    styleTags?: SortOrder
    seasonTags?: SortOrder
    fitTag?: SortOrder
    extraTags?: SortOrder
    confidence?: SortOrder
    rawAiJson?: SortOrder
    userNotes?: SortOrder
    productType?: SortOrder
    color?: SortOrder
    tags?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardrobeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    cutoutImageUrl?: SortOrder
    cutoutStatus?: SortOrder
    cutoutError?: SortOrder
    category?: SortOrder
    colorFamily?: SortOrder
    colorHex?: SortOrder
    styleTags?: SortOrder
    seasonTags?: SortOrder
    fitTag?: SortOrder
    extraTags?: SortOrder
    confidence?: SortOrder
    rawAiJson?: SortOrder
    userNotes?: SortOrder
    productType?: SortOrder
    color?: SortOrder
    tags?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardrobeItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    cutoutImageUrl?: SortOrder
    cutoutStatus?: SortOrder
    cutoutError?: SortOrder
    category?: SortOrder
    colorFamily?: SortOrder
    colorHex?: SortOrder
    styleTags?: SortOrder
    seasonTags?: SortOrder
    fitTag?: SortOrder
    extraTags?: SortOrder
    confidence?: SortOrder
    rawAiJson?: SortOrder
    userNotes?: SortOrder
    productType?: SortOrder
    color?: SortOrder
    tags?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OutfitUserIdWeekStartDateDayIndexCompoundUniqueInput = {
    userId: string
    weekStartDate: Date | string
    dayIndex: number
  }

  export type OutfitCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    dayIndex?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    promptVersion?: SortOrder
    weather?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutfitAvgOrderByAggregateInput = {
    dayIndex?: SortOrder
  }

  export type OutfitMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    dayIndex?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    promptVersion?: SortOrder
    weather?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutfitMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    dayIndex?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    promptVersion?: SortOrder
    weather?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutfitSumOrderByAggregateInput = {
    dayIndex?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type OutfitRelationFilter = {
    is?: OutfitWhereInput
    isNot?: OutfitWhereInput
  }

  export type WardrobeItemRelationFilter = {
    is?: WardrobeItemWhereInput
    isNot?: WardrobeItemWhereInput
  }

  export type OutfitItemOutfitIdWardrobeItemIdCompoundUniqueInput = {
    outfitId: string
    wardrobeItemId: string
  }

  export type OutfitItemCountOrderByAggregateInput = {
    outfitId?: SortOrder
    wardrobeItemId?: SortOrder
  }

  export type OutfitItemMaxOrderByAggregateInput = {
    outfitId?: SortOrder
    wardrobeItemId?: SortOrder
  }

  export type OutfitItemMinOrderByAggregateInput = {
    outfitId?: SortOrder
    wardrobeItemId?: SortOrder
  }

  export type OutfitNullableRelationFilter = {
    is?: OutfitWhereInput | null
    isNot?: OutfitWhereInput | null
  }

  export type RenderJobCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outfitId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RenderJobAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type RenderJobMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outfitId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RenderJobMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outfitId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RenderJobSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type CreditsLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    delta?: SortOrder
    reason?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditsLedgerAvgOrderByAggregateInput = {
    delta?: SortOrder
  }

  export type CreditsLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    delta?: SortOrder
    reason?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditsLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    delta?: SortOrder
    reason?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditsLedgerSumOrderByAggregateInput = {
    delta?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    platform?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    appleOriginalTransactionId?: SortOrder
    appleProductId?: SortOrder
    appleReceiptData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    platform?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    appleOriginalTransactionId?: SortOrder
    appleProductId?: SortOrder
    appleReceiptData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    platform?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    appleOriginalTransactionId?: SortOrder
    appleProductId?: SortOrder
    appleReceiptData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type PurchaseUserIdPlatformExternalIdCompoundUniqueInput = {
    userId: string
    platform: string
    externalId: string
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    productId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    productId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    productId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type UsageUserIdMonthCompoundUniqueInput = {
    userId: string
    month: string
  }

  export type UsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageAvgOrderByAggregateInput = {
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
  }

  export type UsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageSumOrderByAggregateInput = {
    aiGenerationsCount?: SortOrder
    virtualTryonCount?: SortOrder
    weeklyGenerationCount?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EventAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    props?: SortOrder
    createdAt?: SortOrder
  }

  export type EventAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    props?: SortOrder
    createdAt?: SortOrder
  }

  export type EventAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    props?: SortOrder
    createdAt?: SortOrder
  }

  export type HelpCenterMessageListRelationFilter = {
    every?: HelpCenterMessageWhereInput
    some?: HelpCenterMessageWhereInput
    none?: HelpCenterMessageWhereInput
  }

  export type HelpCenterMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpCenterConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCenterConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCenterConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCenterConversationRelationFilter = {
    is?: HelpCenterConversationWhereInput
    isNot?: HelpCenterConversationWhereInput
  }

  export type HelpCenterMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type HelpCenterMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type HelpCenterMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enabled?: SortOrder
    expoPushToken?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    notifyAtLocalTime?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    notifyOnWeatherChange?: SortOrder
    minHoursBetweenNotifs?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    minHoursBetweenNotifs?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enabled?: SortOrder
    expoPushToken?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    notifyAtLocalTime?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    notifyOnWeatherChange?: SortOrder
    minHoursBetweenNotifs?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enabled?: SortOrder
    expoPushToken?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    notifyAtLocalTime?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    notifyOnWeatherChange?: SortOrder
    minHoursBetweenNotifs?: SortOrder
    lastNotifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    coldThresholdC?: SortOrder
    hotThresholdC?: SortOrder
    tempChangeThresholdC?: SortOrder
    minHoursBetweenNotifs?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhotoCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type WardrobeItemCreateNestedManyWithoutUserInput = {
    create?: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput> | WardrobeItemCreateWithoutUserInput[] | WardrobeItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutUserInput | WardrobeItemCreateOrConnectWithoutUserInput[]
    createMany?: WardrobeItemCreateManyUserInputEnvelope
    connect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
  }

  export type OutfitCreateNestedManyWithoutUserInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type RenderJobCreateNestedManyWithoutUserInput = {
    create?: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput> | RenderJobCreateWithoutUserInput[] | RenderJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutUserInput | RenderJobCreateOrConnectWithoutUserInput[]
    createMany?: RenderJobCreateManyUserInputEnvelope
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
  }

  export type CreditsLedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput> | CreditsLedgerCreateWithoutUserInput[] | CreditsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditsLedgerCreateOrConnectWithoutUserInput | CreditsLedgerCreateOrConnectWithoutUserInput[]
    createMany?: CreditsLedgerCreateManyUserInputEnvelope
    connect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type UsageCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput> | UsageCreateWithoutUserInput[] | UsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutUserInput | UsageCreateOrConnectWithoutUserInput[]
    createMany?: UsageCreateManyUserInputEnvelope
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
  }

  export type EventAnalyticsCreateNestedManyWithoutUserInput = {
    create?: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput> | EventAnalyticsCreateWithoutUserInput[] | EventAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAnalyticsCreateOrConnectWithoutUserInput | EventAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: EventAnalyticsCreateManyUserInputEnvelope
    connect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type HelpCenterConversationCreateNestedOneWithoutUserInput = {
    create?: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutUserInput
    connect?: HelpCenterConversationWhereUniqueInput
  }

  export type UserPhotoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type WardrobeItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput> | WardrobeItemCreateWithoutUserInput[] | WardrobeItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutUserInput | WardrobeItemCreateOrConnectWithoutUserInput[]
    createMany?: WardrobeItemCreateManyUserInputEnvelope
    connect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
  }

  export type OutfitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type RenderJobUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput> | RenderJobCreateWithoutUserInput[] | RenderJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutUserInput | RenderJobCreateOrConnectWithoutUserInput[]
    createMany?: RenderJobCreateManyUserInputEnvelope
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
  }

  export type CreditsLedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput> | CreditsLedgerCreateWithoutUserInput[] | CreditsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditsLedgerCreateOrConnectWithoutUserInput | CreditsLedgerCreateOrConnectWithoutUserInput[]
    createMany?: CreditsLedgerCreateManyUserInputEnvelope
    connect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type UsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput> | UsageCreateWithoutUserInput[] | UsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutUserInput | UsageCreateOrConnectWithoutUserInput[]
    createMany?: UsageCreateManyUserInputEnvelope
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
  }

  export type EventAnalyticsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput> | EventAnalyticsCreateWithoutUserInput[] | EventAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAnalyticsCreateOrConnectWithoutUserInput | EventAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: EventAnalyticsCreateManyUserInputEnvelope
    connect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutUserInput
    connect?: HelpCenterConversationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserPhotoUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type WardrobeItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput> | WardrobeItemCreateWithoutUserInput[] | WardrobeItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutUserInput | WardrobeItemCreateOrConnectWithoutUserInput[]
    upsert?: WardrobeItemUpsertWithWhereUniqueWithoutUserInput | WardrobeItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WardrobeItemCreateManyUserInputEnvelope
    set?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    disconnect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    delete?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    connect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    update?: WardrobeItemUpdateWithWhereUniqueWithoutUserInput | WardrobeItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WardrobeItemUpdateManyWithWhereWithoutUserInput | WardrobeItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WardrobeItemScalarWhereInput | WardrobeItemScalarWhereInput[]
  }

  export type OutfitUpdateManyWithoutUserNestedInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutUserInput | OutfitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutUserInput | OutfitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutUserInput | OutfitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type RenderJobUpdateManyWithoutUserNestedInput = {
    create?: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput> | RenderJobCreateWithoutUserInput[] | RenderJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutUserInput | RenderJobCreateOrConnectWithoutUserInput[]
    upsert?: RenderJobUpsertWithWhereUniqueWithoutUserInput | RenderJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RenderJobCreateManyUserInputEnvelope
    set?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    disconnect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    delete?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    update?: RenderJobUpdateWithWhereUniqueWithoutUserInput | RenderJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RenderJobUpdateManyWithWhereWithoutUserInput | RenderJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
  }

  export type CreditsLedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput> | CreditsLedgerCreateWithoutUserInput[] | CreditsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditsLedgerCreateOrConnectWithoutUserInput | CreditsLedgerCreateOrConnectWithoutUserInput[]
    upsert?: CreditsLedgerUpsertWithWhereUniqueWithoutUserInput | CreditsLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditsLedgerCreateManyUserInputEnvelope
    set?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    disconnect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    delete?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    connect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    update?: CreditsLedgerUpdateWithWhereUniqueWithoutUserInput | CreditsLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditsLedgerUpdateManyWithWhereWithoutUserInput | CreditsLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditsLedgerScalarWhereInput | CreditsLedgerScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type UsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput> | UsageCreateWithoutUserInput[] | UsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutUserInput | UsageCreateOrConnectWithoutUserInput[]
    upsert?: UsageUpsertWithWhereUniqueWithoutUserInput | UsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageCreateManyUserInputEnvelope
    set?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    disconnect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    delete?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    update?: UsageUpdateWithWhereUniqueWithoutUserInput | UsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageUpdateManyWithWhereWithoutUserInput | UsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageScalarWhereInput | UsageScalarWhereInput[]
  }

  export type EventAnalyticsUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput> | EventAnalyticsCreateWithoutUserInput[] | EventAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAnalyticsCreateOrConnectWithoutUserInput | EventAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: EventAnalyticsUpsertWithWhereUniqueWithoutUserInput | EventAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventAnalyticsCreateManyUserInputEnvelope
    set?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    disconnect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    delete?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    connect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    update?: EventAnalyticsUpdateWithWhereUniqueWithoutUserInput | EventAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventAnalyticsUpdateManyWithWhereWithoutUserInput | EventAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventAnalyticsScalarWhereInput | EventAnalyticsScalarWhereInput[]
  }

  export type NotificationSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type HelpCenterConversationUpdateOneWithoutUserNestedInput = {
    create?: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutUserInput
    upsert?: HelpCenterConversationUpsertWithoutUserInput
    disconnect?: HelpCenterConversationWhereInput | boolean
    delete?: HelpCenterConversationWhereInput | boolean
    connect?: HelpCenterConversationWhereUniqueInput
    update?: XOR<XOR<HelpCenterConversationUpdateToOneWithWhereWithoutUserInput, HelpCenterConversationUpdateWithoutUserInput>, HelpCenterConversationUncheckedUpdateWithoutUserInput>
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type WardrobeItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput> | WardrobeItemCreateWithoutUserInput[] | WardrobeItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutUserInput | WardrobeItemCreateOrConnectWithoutUserInput[]
    upsert?: WardrobeItemUpsertWithWhereUniqueWithoutUserInput | WardrobeItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WardrobeItemCreateManyUserInputEnvelope
    set?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    disconnect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    delete?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    connect?: WardrobeItemWhereUniqueInput | WardrobeItemWhereUniqueInput[]
    update?: WardrobeItemUpdateWithWhereUniqueWithoutUserInput | WardrobeItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WardrobeItemUpdateManyWithWhereWithoutUserInput | WardrobeItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WardrobeItemScalarWhereInput | WardrobeItemScalarWhereInput[]
  }

  export type OutfitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutUserInput | OutfitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutUserInput | OutfitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutUserInput | OutfitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type RenderJobUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput> | RenderJobCreateWithoutUserInput[] | RenderJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutUserInput | RenderJobCreateOrConnectWithoutUserInput[]
    upsert?: RenderJobUpsertWithWhereUniqueWithoutUserInput | RenderJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RenderJobCreateManyUserInputEnvelope
    set?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    disconnect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    delete?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    update?: RenderJobUpdateWithWhereUniqueWithoutUserInput | RenderJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RenderJobUpdateManyWithWhereWithoutUserInput | RenderJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
  }

  export type CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput> | CreditsLedgerCreateWithoutUserInput[] | CreditsLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditsLedgerCreateOrConnectWithoutUserInput | CreditsLedgerCreateOrConnectWithoutUserInput[]
    upsert?: CreditsLedgerUpsertWithWhereUniqueWithoutUserInput | CreditsLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditsLedgerCreateManyUserInputEnvelope
    set?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    disconnect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    delete?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    connect?: CreditsLedgerWhereUniqueInput | CreditsLedgerWhereUniqueInput[]
    update?: CreditsLedgerUpdateWithWhereUniqueWithoutUserInput | CreditsLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditsLedgerUpdateManyWithWhereWithoutUserInput | CreditsLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditsLedgerScalarWhereInput | CreditsLedgerScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type UsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput> | UsageCreateWithoutUserInput[] | UsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutUserInput | UsageCreateOrConnectWithoutUserInput[]
    upsert?: UsageUpsertWithWhereUniqueWithoutUserInput | UsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageCreateManyUserInputEnvelope
    set?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    disconnect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    delete?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    update?: UsageUpdateWithWhereUniqueWithoutUserInput | UsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageUpdateManyWithWhereWithoutUserInput | UsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageScalarWhereInput | UsageScalarWhereInput[]
  }

  export type EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput> | EventAnalyticsCreateWithoutUserInput[] | EventAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAnalyticsCreateOrConnectWithoutUserInput | EventAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: EventAnalyticsUpsertWithWhereUniqueWithoutUserInput | EventAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventAnalyticsCreateManyUserInputEnvelope
    set?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    disconnect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    delete?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    connect?: EventAnalyticsWhereUniqueInput | EventAnalyticsWhereUniqueInput[]
    update?: EventAnalyticsUpdateWithWhereUniqueWithoutUserInput | EventAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventAnalyticsUpdateManyWithWhereWithoutUserInput | EventAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventAnalyticsScalarWhereInput | EventAnalyticsScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutUserInput
    upsert?: HelpCenterConversationUpsertWithoutUserInput
    disconnect?: HelpCenterConversationWhereInput | boolean
    delete?: HelpCenterConversationWhereInput | boolean
    connect?: HelpCenterConversationWhereUniqueInput
    update?: XOR<XOR<HelpCenterConversationUpdateToOneWithWhereWithoutUserInput, HelpCenterConversationUpdateWithoutUserInput>, HelpCenterConversationUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutPhotosInput = {
    create?: XOR<UserCreateWithoutPhotosInput, UserUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<UserCreateWithoutPhotosInput, UserUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhotosInput
    upsert?: UserUpsertWithoutPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhotosInput, UserUpdateWithoutPhotosInput>, UserUncheckedUpdateWithoutPhotosInput>
  }

  export type UserCreateNestedOneWithoutWardrobeItemsInput = {
    create?: XOR<UserCreateWithoutWardrobeItemsInput, UserUncheckedCreateWithoutWardrobeItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWardrobeItemsInput
    connect?: UserWhereUniqueInput
  }

  export type OutfitItemCreateNestedManyWithoutWardrobeItemInput = {
    create?: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput> | OutfitItemCreateWithoutWardrobeItemInput[] | OutfitItemUncheckedCreateWithoutWardrobeItemInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutWardrobeItemInput | OutfitItemCreateOrConnectWithoutWardrobeItemInput[]
    createMany?: OutfitItemCreateManyWardrobeItemInputEnvelope
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
  }

  export type OutfitItemUncheckedCreateNestedManyWithoutWardrobeItemInput = {
    create?: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput> | OutfitItemCreateWithoutWardrobeItemInput[] | OutfitItemUncheckedCreateWithoutWardrobeItemInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutWardrobeItemInput | OutfitItemCreateOrConnectWithoutWardrobeItemInput[]
    createMany?: OutfitItemCreateManyWardrobeItemInputEnvelope
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWardrobeItemsNestedInput = {
    create?: XOR<UserCreateWithoutWardrobeItemsInput, UserUncheckedCreateWithoutWardrobeItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWardrobeItemsInput
    upsert?: UserUpsertWithoutWardrobeItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWardrobeItemsInput, UserUpdateWithoutWardrobeItemsInput>, UserUncheckedUpdateWithoutWardrobeItemsInput>
  }

  export type OutfitItemUpdateManyWithoutWardrobeItemNestedInput = {
    create?: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput> | OutfitItemCreateWithoutWardrobeItemInput[] | OutfitItemUncheckedCreateWithoutWardrobeItemInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutWardrobeItemInput | OutfitItemCreateOrConnectWithoutWardrobeItemInput[]
    upsert?: OutfitItemUpsertWithWhereUniqueWithoutWardrobeItemInput | OutfitItemUpsertWithWhereUniqueWithoutWardrobeItemInput[]
    createMany?: OutfitItemCreateManyWardrobeItemInputEnvelope
    set?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    disconnect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    delete?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    update?: OutfitItemUpdateWithWhereUniqueWithoutWardrobeItemInput | OutfitItemUpdateWithWhereUniqueWithoutWardrobeItemInput[]
    updateMany?: OutfitItemUpdateManyWithWhereWithoutWardrobeItemInput | OutfitItemUpdateManyWithWhereWithoutWardrobeItemInput[]
    deleteMany?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
  }

  export type OutfitItemUncheckedUpdateManyWithoutWardrobeItemNestedInput = {
    create?: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput> | OutfitItemCreateWithoutWardrobeItemInput[] | OutfitItemUncheckedCreateWithoutWardrobeItemInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutWardrobeItemInput | OutfitItemCreateOrConnectWithoutWardrobeItemInput[]
    upsert?: OutfitItemUpsertWithWhereUniqueWithoutWardrobeItemInput | OutfitItemUpsertWithWhereUniqueWithoutWardrobeItemInput[]
    createMany?: OutfitItemCreateManyWardrobeItemInputEnvelope
    set?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    disconnect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    delete?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    update?: OutfitItemUpdateWithWhereUniqueWithoutWardrobeItemInput | OutfitItemUpdateWithWhereUniqueWithoutWardrobeItemInput[]
    updateMany?: OutfitItemUpdateManyWithWhereWithoutWardrobeItemInput | OutfitItemUpdateManyWithWhereWithoutWardrobeItemInput[]
    deleteMany?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOutfitsInput = {
    create?: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutfitsInput
    connect?: UserWhereUniqueInput
  }

  export type OutfitItemCreateNestedManyWithoutOutfitInput = {
    create?: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput> | OutfitItemCreateWithoutOutfitInput[] | OutfitItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutOutfitInput | OutfitItemCreateOrConnectWithoutOutfitInput[]
    createMany?: OutfitItemCreateManyOutfitInputEnvelope
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
  }

  export type RenderJobCreateNestedManyWithoutOutfitInput = {
    create?: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput> | RenderJobCreateWithoutOutfitInput[] | RenderJobUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutOutfitInput | RenderJobCreateOrConnectWithoutOutfitInput[]
    createMany?: RenderJobCreateManyOutfitInputEnvelope
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
  }

  export type OutfitItemUncheckedCreateNestedManyWithoutOutfitInput = {
    create?: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput> | OutfitItemCreateWithoutOutfitInput[] | OutfitItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutOutfitInput | OutfitItemCreateOrConnectWithoutOutfitInput[]
    createMany?: OutfitItemCreateManyOutfitInputEnvelope
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
  }

  export type RenderJobUncheckedCreateNestedManyWithoutOutfitInput = {
    create?: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput> | RenderJobCreateWithoutOutfitInput[] | RenderJobUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutOutfitInput | RenderJobCreateOrConnectWithoutOutfitInput[]
    createMany?: RenderJobCreateManyOutfitInputEnvelope
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutOutfitsNestedInput = {
    create?: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutfitsInput
    upsert?: UserUpsertWithoutOutfitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOutfitsInput, UserUpdateWithoutOutfitsInput>, UserUncheckedUpdateWithoutOutfitsInput>
  }

  export type OutfitItemUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput> | OutfitItemCreateWithoutOutfitInput[] | OutfitItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutOutfitInput | OutfitItemCreateOrConnectWithoutOutfitInput[]
    upsert?: OutfitItemUpsertWithWhereUniqueWithoutOutfitInput | OutfitItemUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: OutfitItemCreateManyOutfitInputEnvelope
    set?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    disconnect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    delete?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    update?: OutfitItemUpdateWithWhereUniqueWithoutOutfitInput | OutfitItemUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: OutfitItemUpdateManyWithWhereWithoutOutfitInput | OutfitItemUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
  }

  export type RenderJobUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput> | RenderJobCreateWithoutOutfitInput[] | RenderJobUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutOutfitInput | RenderJobCreateOrConnectWithoutOutfitInput[]
    upsert?: RenderJobUpsertWithWhereUniqueWithoutOutfitInput | RenderJobUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: RenderJobCreateManyOutfitInputEnvelope
    set?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    disconnect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    delete?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    update?: RenderJobUpdateWithWhereUniqueWithoutOutfitInput | RenderJobUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: RenderJobUpdateManyWithWhereWithoutOutfitInput | RenderJobUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
  }

  export type OutfitItemUncheckedUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput> | OutfitItemCreateWithoutOutfitInput[] | OutfitItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitItemCreateOrConnectWithoutOutfitInput | OutfitItemCreateOrConnectWithoutOutfitInput[]
    upsert?: OutfitItemUpsertWithWhereUniqueWithoutOutfitInput | OutfitItemUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: OutfitItemCreateManyOutfitInputEnvelope
    set?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    disconnect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    delete?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    connect?: OutfitItemWhereUniqueInput | OutfitItemWhereUniqueInput[]
    update?: OutfitItemUpdateWithWhereUniqueWithoutOutfitInput | OutfitItemUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: OutfitItemUpdateManyWithWhereWithoutOutfitInput | OutfitItemUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
  }

  export type RenderJobUncheckedUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput> | RenderJobCreateWithoutOutfitInput[] | RenderJobUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: RenderJobCreateOrConnectWithoutOutfitInput | RenderJobCreateOrConnectWithoutOutfitInput[]
    upsert?: RenderJobUpsertWithWhereUniqueWithoutOutfitInput | RenderJobUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: RenderJobCreateManyOutfitInputEnvelope
    set?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    disconnect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    delete?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    connect?: RenderJobWhereUniqueInput | RenderJobWhereUniqueInput[]
    update?: RenderJobUpdateWithWhereUniqueWithoutOutfitInput | RenderJobUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: RenderJobUpdateManyWithWhereWithoutOutfitInput | RenderJobUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
  }

  export type OutfitCreateNestedOneWithoutOutfitItemsInput = {
    create?: XOR<OutfitCreateWithoutOutfitItemsInput, OutfitUncheckedCreateWithoutOutfitItemsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutOutfitItemsInput
    connect?: OutfitWhereUniqueInput
  }

  export type WardrobeItemCreateNestedOneWithoutOutfitItemsInput = {
    create?: XOR<WardrobeItemCreateWithoutOutfitItemsInput, WardrobeItemUncheckedCreateWithoutOutfitItemsInput>
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutOutfitItemsInput
    connect?: WardrobeItemWhereUniqueInput
  }

  export type OutfitUpdateOneRequiredWithoutOutfitItemsNestedInput = {
    create?: XOR<OutfitCreateWithoutOutfitItemsInput, OutfitUncheckedCreateWithoutOutfitItemsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutOutfitItemsInput
    upsert?: OutfitUpsertWithoutOutfitItemsInput
    connect?: OutfitWhereUniqueInput
    update?: XOR<XOR<OutfitUpdateToOneWithWhereWithoutOutfitItemsInput, OutfitUpdateWithoutOutfitItemsInput>, OutfitUncheckedUpdateWithoutOutfitItemsInput>
  }

  export type WardrobeItemUpdateOneRequiredWithoutOutfitItemsNestedInput = {
    create?: XOR<WardrobeItemCreateWithoutOutfitItemsInput, WardrobeItemUncheckedCreateWithoutOutfitItemsInput>
    connectOrCreate?: WardrobeItemCreateOrConnectWithoutOutfitItemsInput
    upsert?: WardrobeItemUpsertWithoutOutfitItemsInput
    connect?: WardrobeItemWhereUniqueInput
    update?: XOR<XOR<WardrobeItemUpdateToOneWithWhereWithoutOutfitItemsInput, WardrobeItemUpdateWithoutOutfitItemsInput>, WardrobeItemUncheckedUpdateWithoutOutfitItemsInput>
  }

  export type UserCreateNestedOneWithoutRenderJobsInput = {
    create?: XOR<UserCreateWithoutRenderJobsInput, UserUncheckedCreateWithoutRenderJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRenderJobsInput
    connect?: UserWhereUniqueInput
  }

  export type OutfitCreateNestedOneWithoutRenderJobsInput = {
    create?: XOR<OutfitCreateWithoutRenderJobsInput, OutfitUncheckedCreateWithoutRenderJobsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutRenderJobsInput
    connect?: OutfitWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRenderJobsNestedInput = {
    create?: XOR<UserCreateWithoutRenderJobsInput, UserUncheckedCreateWithoutRenderJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRenderJobsInput
    upsert?: UserUpsertWithoutRenderJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRenderJobsInput, UserUpdateWithoutRenderJobsInput>, UserUncheckedUpdateWithoutRenderJobsInput>
  }

  export type OutfitUpdateOneWithoutRenderJobsNestedInput = {
    create?: XOR<OutfitCreateWithoutRenderJobsInput, OutfitUncheckedCreateWithoutRenderJobsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutRenderJobsInput
    upsert?: OutfitUpsertWithoutRenderJobsInput
    disconnect?: OutfitWhereInput | boolean
    delete?: OutfitWhereInput | boolean
    connect?: OutfitWhereUniqueInput
    update?: XOR<XOR<OutfitUpdateToOneWithWhereWithoutRenderJobsInput, OutfitUpdateWithoutRenderJobsInput>, OutfitUncheckedUpdateWithoutRenderJobsInput>
  }

  export type UserCreateNestedOneWithoutCreditsLedgerInput = {
    create?: XOR<UserCreateWithoutCreditsLedgerInput, UserUncheckedCreateWithoutCreditsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreditsLedgerNestedInput = {
    create?: XOR<UserCreateWithoutCreditsLedgerInput, UserUncheckedCreateWithoutCreditsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsLedgerInput
    upsert?: UserUpsertWithoutCreditsLedgerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditsLedgerInput, UserUpdateWithoutCreditsLedgerInput>, UserUncheckedUpdateWithoutCreditsLedgerInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput> | PurchaseCreateWithoutSubscriptionInput[] | PurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSubscriptionInput | PurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PurchaseCreateManySubscriptionInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput> | PurchaseCreateWithoutSubscriptionInput[] | PurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSubscriptionInput | PurchaseCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PurchaseCreateManySubscriptionInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PurchaseUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput> | PurchaseCreateWithoutSubscriptionInput[] | PurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSubscriptionInput | PurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | PurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PurchaseCreateManySubscriptionInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | PurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSubscriptionInput | PurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput> | PurchaseCreateWithoutSubscriptionInput[] | PurchaseUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSubscriptionInput | PurchaseCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSubscriptionInput | PurchaseUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PurchaseCreateManySubscriptionInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSubscriptionInput | PurchaseUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSubscriptionInput | PurchaseUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<SubscriptionCreateWithoutPurchasesInput, SubscriptionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPurchasesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type SubscriptionUpdateOneWithoutPurchasesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPurchasesInput, SubscriptionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPurchasesInput
    upsert?: SubscriptionUpsertWithoutPurchasesInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPurchasesInput, SubscriptionUpdateWithoutPurchasesInput>, SubscriptionUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<UserCreateWithoutUsageRecordsInput, UserUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<UserCreateWithoutUsageRecordsInput, UserUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageRecordsInput
    upsert?: UserUpsertWithoutUsageRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageRecordsInput, UserUpdateWithoutUsageRecordsInput>, UserUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type UserCreateNestedOneWithoutEventsAnalyticsInput = {
    create?: XOR<UserCreateWithoutEventsAnalyticsInput, UserUncheckedCreateWithoutEventsAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutEventsAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutEventsAnalyticsInput, UserUncheckedCreateWithoutEventsAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsAnalyticsInput
    upsert?: UserUpsertWithoutEventsAnalyticsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsAnalyticsInput, UserUpdateWithoutEventsAnalyticsInput>, UserUncheckedUpdateWithoutEventsAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutHelpCenterConversationInput = {
    create?: XOR<UserCreateWithoutHelpCenterConversationInput, UserUncheckedCreateWithoutHelpCenterConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpCenterConversationInput
    connect?: UserWhereUniqueInput
  }

  export type HelpCenterMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput> | HelpCenterMessageCreateWithoutConversationInput[] | HelpCenterMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: HelpCenterMessageCreateOrConnectWithoutConversationInput | HelpCenterMessageCreateOrConnectWithoutConversationInput[]
    createMany?: HelpCenterMessageCreateManyConversationInputEnvelope
    connect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
  }

  export type HelpCenterMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput> | HelpCenterMessageCreateWithoutConversationInput[] | HelpCenterMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: HelpCenterMessageCreateOrConnectWithoutConversationInput | HelpCenterMessageCreateOrConnectWithoutConversationInput[]
    createMany?: HelpCenterMessageCreateManyConversationInputEnvelope
    connect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHelpCenterConversationNestedInput = {
    create?: XOR<UserCreateWithoutHelpCenterConversationInput, UserUncheckedCreateWithoutHelpCenterConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpCenterConversationInput
    upsert?: UserUpsertWithoutHelpCenterConversationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelpCenterConversationInput, UserUpdateWithoutHelpCenterConversationInput>, UserUncheckedUpdateWithoutHelpCenterConversationInput>
  }

  export type HelpCenterMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput> | HelpCenterMessageCreateWithoutConversationInput[] | HelpCenterMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: HelpCenterMessageCreateOrConnectWithoutConversationInput | HelpCenterMessageCreateOrConnectWithoutConversationInput[]
    upsert?: HelpCenterMessageUpsertWithWhereUniqueWithoutConversationInput | HelpCenterMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: HelpCenterMessageCreateManyConversationInputEnvelope
    set?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    disconnect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    delete?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    connect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    update?: HelpCenterMessageUpdateWithWhereUniqueWithoutConversationInput | HelpCenterMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: HelpCenterMessageUpdateManyWithWhereWithoutConversationInput | HelpCenterMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: HelpCenterMessageScalarWhereInput | HelpCenterMessageScalarWhereInput[]
  }

  export type HelpCenterMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput> | HelpCenterMessageCreateWithoutConversationInput[] | HelpCenterMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: HelpCenterMessageCreateOrConnectWithoutConversationInput | HelpCenterMessageCreateOrConnectWithoutConversationInput[]
    upsert?: HelpCenterMessageUpsertWithWhereUniqueWithoutConversationInput | HelpCenterMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: HelpCenterMessageCreateManyConversationInputEnvelope
    set?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    disconnect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    delete?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    connect?: HelpCenterMessageWhereUniqueInput | HelpCenterMessageWhereUniqueInput[]
    update?: HelpCenterMessageUpdateWithWhereUniqueWithoutConversationInput | HelpCenterMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: HelpCenterMessageUpdateManyWithWhereWithoutConversationInput | HelpCenterMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: HelpCenterMessageScalarWhereInput | HelpCenterMessageScalarWhereInput[]
  }

  export type HelpCenterConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<HelpCenterConversationCreateWithoutMessagesInput, HelpCenterConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutMessagesInput
    connect?: HelpCenterConversationWhereUniqueInput
  }

  export type HelpCenterConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<HelpCenterConversationCreateWithoutMessagesInput, HelpCenterConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: HelpCenterConversationCreateOrConnectWithoutMessagesInput
    upsert?: HelpCenterConversationUpsertWithoutMessagesInput
    connect?: HelpCenterConversationWhereUniqueInput
    update?: XOR<XOR<HelpCenterConversationUpdateToOneWithWhereWithoutMessagesInput, HelpCenterConversationUpdateWithoutMessagesInput>, HelpCenterConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserPhotoCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoUncheckedCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoCreateOrConnectWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoCreateManyUserInputEnvelope = {
    data: UserPhotoCreateManyUserInput | UserPhotoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WardrobeItemCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemCreateNestedManyWithoutWardrobeItemInput
  }

  export type WardrobeItemUncheckedCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemUncheckedCreateNestedManyWithoutWardrobeItemInput
  }

  export type WardrobeItemCreateOrConnectWithoutUserInput = {
    where: WardrobeItemWhereUniqueInput
    create: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput>
  }

  export type WardrobeItemCreateManyUserInputEnvelope = {
    data: WardrobeItemCreateManyUserInput | WardrobeItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OutfitCreateWithoutUserInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemCreateNestedManyWithoutOutfitInput
    renderJobs?: RenderJobCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutUserInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemUncheckedCreateNestedManyWithoutOutfitInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutUserInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput>
  }

  export type OutfitCreateManyUserInputEnvelope = {
    data: OutfitCreateManyUserInput | OutfitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RenderJobCreateWithoutUserInput = {
    id?: string
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfit?: OutfitCreateNestedOneWithoutRenderJobsInput
  }

  export type RenderJobUncheckedCreateWithoutUserInput = {
    id?: string
    outfitId?: string | null
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RenderJobCreateOrConnectWithoutUserInput = {
    where: RenderJobWhereUniqueInput
    create: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput>
  }

  export type RenderJobCreateManyUserInputEnvelope = {
    data: RenderJobCreateManyUserInput | RenderJobCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CreditsLedgerCreateWithoutUserInput = {
    id?: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
  }

  export type CreditsLedgerUncheckedCreateWithoutUserInput = {
    id?: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
  }

  export type CreditsLedgerCreateOrConnectWithoutUserInput = {
    where: CreditsLedgerWhereUniqueInput
    create: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput>
  }

  export type CreditsLedgerCreateManyUserInputEnvelope = {
    data: CreditsLedgerCreateManyUserInput | CreditsLedgerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutUserInput = {
    id?: string
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionId?: string | null
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseCreateManyUserInputEnvelope = {
    data: PurchaseCreateManyUserInput | PurchaseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageCreateWithoutUserInput = {
    id?: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
  }

  export type UsageUncheckedCreateWithoutUserInput = {
    id?: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
  }

  export type UsageCreateOrConnectWithoutUserInput = {
    where: UsageWhereUniqueInput
    create: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput>
  }

  export type UsageCreateManyUserInputEnvelope = {
    data: UsageCreateManyUserInput | UsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventAnalyticsCreateWithoutUserInput = {
    id?: string
    eventName: string
    props?: string | null
    createdAt?: Date | string
  }

  export type EventAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    eventName: string
    props?: string | null
    createdAt?: Date | string
  }

  export type EventAnalyticsCreateOrConnectWithoutUserInput = {
    where: EventAnalyticsWhereUniqueInput
    create: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type EventAnalyticsCreateManyUserInputEnvelope = {
    data: EventAnalyticsCreateManyUserInput | EventAnalyticsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    id?: string
    enabled?: boolean
    expoPushToken?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    notifyAtLocalTime?: string
    coldThresholdC?: number
    hotThresholdC?: number
    tempChangeThresholdC?: number
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: number
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    enabled?: boolean
    expoPushToken?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    notifyAtLocalTime?: string
    coldThresholdC?: number
    hotThresholdC?: number
    tempChangeThresholdC?: number
    notifyOnWeatherChange?: boolean
    minHoursBetweenNotifs?: number
    lastNotifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HelpCenterConversationCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: HelpCenterMessageCreateNestedManyWithoutConversationInput
  }

  export type HelpCenterConversationUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: HelpCenterMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type HelpCenterConversationCreateOrConnectWithoutUserInput = {
    where: HelpCenterConversationWhereUniqueInput
    create: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    update: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    data: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
  }

  export type UserPhotoUpdateManyWithWhereWithoutUserInput = {
    where: UserPhotoScalarWhereInput
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPhotoScalarWhereInput = {
    AND?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    OR?: UserPhotoScalarWhereInput[]
    NOT?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    imageUrl?: StringFilter<"UserPhoto"> | string
    isPrimary?: BoolFilter<"UserPhoto"> | boolean
    metadata?: StringNullableFilter<"UserPhoto"> | string | null
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
  }

  export type WardrobeItemUpsertWithWhereUniqueWithoutUserInput = {
    where: WardrobeItemWhereUniqueInput
    update: XOR<WardrobeItemUpdateWithoutUserInput, WardrobeItemUncheckedUpdateWithoutUserInput>
    create: XOR<WardrobeItemCreateWithoutUserInput, WardrobeItemUncheckedCreateWithoutUserInput>
  }

  export type WardrobeItemUpdateWithWhereUniqueWithoutUserInput = {
    where: WardrobeItemWhereUniqueInput
    data: XOR<WardrobeItemUpdateWithoutUserInput, WardrobeItemUncheckedUpdateWithoutUserInput>
  }

  export type WardrobeItemUpdateManyWithWhereWithoutUserInput = {
    where: WardrobeItemScalarWhereInput
    data: XOR<WardrobeItemUpdateManyMutationInput, WardrobeItemUncheckedUpdateManyWithoutUserInput>
  }

  export type WardrobeItemScalarWhereInput = {
    AND?: WardrobeItemScalarWhereInput | WardrobeItemScalarWhereInput[]
    OR?: WardrobeItemScalarWhereInput[]
    NOT?: WardrobeItemScalarWhereInput | WardrobeItemScalarWhereInput[]
    id?: StringFilter<"WardrobeItem"> | string
    userId?: StringFilter<"WardrobeItem"> | string
    imageUrl?: StringFilter<"WardrobeItem"> | string
    cutoutImageUrl?: StringNullableFilter<"WardrobeItem"> | string | null
    cutoutStatus?: StringFilter<"WardrobeItem"> | string
    cutoutError?: StringNullableFilter<"WardrobeItem"> | string | null
    category?: StringFilter<"WardrobeItem"> | string
    colorFamily?: StringFilter<"WardrobeItem"> | string
    colorHex?: StringNullableFilter<"WardrobeItem"> | string | null
    styleTags?: StringFilter<"WardrobeItem"> | string
    seasonTags?: StringFilter<"WardrobeItem"> | string
    fitTag?: StringFilter<"WardrobeItem"> | string
    extraTags?: StringNullableFilter<"WardrobeItem"> | string | null
    confidence?: StringFilter<"WardrobeItem"> | string
    rawAiJson?: StringNullableFilter<"WardrobeItem"> | string | null
    userNotes?: StringNullableFilter<"WardrobeItem"> | string | null
    productType?: StringNullableFilter<"WardrobeItem"> | string | null
    color?: StringNullableFilter<"WardrobeItem"> | string | null
    tags?: StringNullableFilter<"WardrobeItem"> | string | null
    brand?: StringNullableFilter<"WardrobeItem"> | string | null
    size?: StringNullableFilter<"WardrobeItem"> | string | null
    createdAt?: DateTimeFilter<"WardrobeItem"> | Date | string
    updatedAt?: DateTimeFilter<"WardrobeItem"> | Date | string
  }

  export type OutfitUpsertWithWhereUniqueWithoutUserInput = {
    where: OutfitWhereUniqueInput
    update: XOR<OutfitUpdateWithoutUserInput, OutfitUncheckedUpdateWithoutUserInput>
    create: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput>
  }

  export type OutfitUpdateWithWhereUniqueWithoutUserInput = {
    where: OutfitWhereUniqueInput
    data: XOR<OutfitUpdateWithoutUserInput, OutfitUncheckedUpdateWithoutUserInput>
  }

  export type OutfitUpdateManyWithWhereWithoutUserInput = {
    where: OutfitScalarWhereInput
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyWithoutUserInput>
  }

  export type OutfitScalarWhereInput = {
    AND?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
    OR?: OutfitScalarWhereInput[]
    NOT?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
    id?: StringFilter<"Outfit"> | string
    userId?: StringFilter<"Outfit"> | string
    weekStartDate?: DateTimeFilter<"Outfit"> | Date | string
    dayIndex?: IntFilter<"Outfit"> | number
    status?: StringFilter<"Outfit"> | string
    imageUrl?: StringNullableFilter<"Outfit"> | string | null
    promptVersion?: StringNullableFilter<"Outfit"> | string | null
    weather?: StringNullableFilter<"Outfit"> | string | null
    category?: StringNullableFilter<"Outfit"> | string | null
    createdAt?: DateTimeFilter<"Outfit"> | Date | string
    updatedAt?: DateTimeFilter<"Outfit"> | Date | string
  }

  export type RenderJobUpsertWithWhereUniqueWithoutUserInput = {
    where: RenderJobWhereUniqueInput
    update: XOR<RenderJobUpdateWithoutUserInput, RenderJobUncheckedUpdateWithoutUserInput>
    create: XOR<RenderJobCreateWithoutUserInput, RenderJobUncheckedCreateWithoutUserInput>
  }

  export type RenderJobUpdateWithWhereUniqueWithoutUserInput = {
    where: RenderJobWhereUniqueInput
    data: XOR<RenderJobUpdateWithoutUserInput, RenderJobUncheckedUpdateWithoutUserInput>
  }

  export type RenderJobUpdateManyWithWhereWithoutUserInput = {
    where: RenderJobScalarWhereInput
    data: XOR<RenderJobUpdateManyMutationInput, RenderJobUncheckedUpdateManyWithoutUserInput>
  }

  export type RenderJobScalarWhereInput = {
    AND?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
    OR?: RenderJobScalarWhereInput[]
    NOT?: RenderJobScalarWhereInput | RenderJobScalarWhereInput[]
    id?: StringFilter<"RenderJob"> | string
    userId?: StringFilter<"RenderJob"> | string
    outfitId?: StringNullableFilter<"RenderJob"> | string | null
    status?: StringFilter<"RenderJob"> | string
    attempts?: IntFilter<"RenderJob"> | number
    error?: StringNullableFilter<"RenderJob"> | string | null
    startedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"RenderJob"> | Date | string | null
    createdAt?: DateTimeFilter<"RenderJob"> | Date | string
    updatedAt?: DateTimeFilter<"RenderJob"> | Date | string
  }

  export type CreditsLedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: CreditsLedgerWhereUniqueInput
    update: XOR<CreditsLedgerUpdateWithoutUserInput, CreditsLedgerUncheckedUpdateWithoutUserInput>
    create: XOR<CreditsLedgerCreateWithoutUserInput, CreditsLedgerUncheckedCreateWithoutUserInput>
  }

  export type CreditsLedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: CreditsLedgerWhereUniqueInput
    data: XOR<CreditsLedgerUpdateWithoutUserInput, CreditsLedgerUncheckedUpdateWithoutUserInput>
  }

  export type CreditsLedgerUpdateManyWithWhereWithoutUserInput = {
    where: CreditsLedgerScalarWhereInput
    data: XOR<CreditsLedgerUpdateManyMutationInput, CreditsLedgerUncheckedUpdateManyWithoutUserInput>
  }

  export type CreditsLedgerScalarWhereInput = {
    AND?: CreditsLedgerScalarWhereInput | CreditsLedgerScalarWhereInput[]
    OR?: CreditsLedgerScalarWhereInput[]
    NOT?: CreditsLedgerScalarWhereInput | CreditsLedgerScalarWhereInput[]
    id?: StringFilter<"CreditsLedger"> | string
    userId?: StringFilter<"CreditsLedger"> | string
    delta?: IntFilter<"CreditsLedger"> | number
    reason?: StringFilter<"CreditsLedger"> | string
    refId?: StringNullableFilter<"CreditsLedger"> | string | null
    createdAt?: DateTimeFilter<"CreditsLedger"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    platform?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    appleOriginalTransactionId?: StringNullableFilter<"Subscription"> | string | null
    appleProductId?: StringNullableFilter<"Subscription"> | string | null
    appleReceiptData?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    subscriptionId?: StringNullableFilter<"Purchase"> | string | null
    platform?: StringFilter<"Purchase"> | string
    externalId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    plan?: StringFilter<"Purchase"> | string
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntNullableFilter<"Purchase"> | number | null
    currency?: StringNullableFilter<"Purchase"> | string | null
    periodStart?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    metadata?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type UsageUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageWhereUniqueInput
    update: XOR<UsageUpdateWithoutUserInput, UsageUncheckedUpdateWithoutUserInput>
    create: XOR<UsageCreateWithoutUserInput, UsageUncheckedCreateWithoutUserInput>
  }

  export type UsageUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageWhereUniqueInput
    data: XOR<UsageUpdateWithoutUserInput, UsageUncheckedUpdateWithoutUserInput>
  }

  export type UsageUpdateManyWithWhereWithoutUserInput = {
    where: UsageScalarWhereInput
    data: XOR<UsageUpdateManyMutationInput, UsageUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageScalarWhereInput = {
    AND?: UsageScalarWhereInput | UsageScalarWhereInput[]
    OR?: UsageScalarWhereInput[]
    NOT?: UsageScalarWhereInput | UsageScalarWhereInput[]
    id?: StringFilter<"Usage"> | string
    userId?: StringFilter<"Usage"> | string
    month?: StringFilter<"Usage"> | string
    aiGenerationsCount?: IntFilter<"Usage"> | number
    virtualTryonCount?: IntFilter<"Usage"> | number
    weeklyGenerationCount?: IntFilter<"Usage"> | number
    createdAt?: DateTimeFilter<"Usage"> | Date | string
  }

  export type EventAnalyticsUpsertWithWhereUniqueWithoutUserInput = {
    where: EventAnalyticsWhereUniqueInput
    update: XOR<EventAnalyticsUpdateWithoutUserInput, EventAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<EventAnalyticsCreateWithoutUserInput, EventAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type EventAnalyticsUpdateWithWhereUniqueWithoutUserInput = {
    where: EventAnalyticsWhereUniqueInput
    data: XOR<EventAnalyticsUpdateWithoutUserInput, EventAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type EventAnalyticsUpdateManyWithWhereWithoutUserInput = {
    where: EventAnalyticsScalarWhereInput
    data: XOR<EventAnalyticsUpdateManyMutationInput, EventAnalyticsUncheckedUpdateManyWithoutUserInput>
  }

  export type EventAnalyticsScalarWhereInput = {
    AND?: EventAnalyticsScalarWhereInput | EventAnalyticsScalarWhereInput[]
    OR?: EventAnalyticsScalarWhereInput[]
    NOT?: EventAnalyticsScalarWhereInput | EventAnalyticsScalarWhereInput[]
    id?: StringFilter<"EventAnalytics"> | string
    userId?: StringNullableFilter<"EventAnalytics"> | string | null
    eventName?: StringFilter<"EventAnalytics"> | string
    props?: StringNullableFilter<"EventAnalytics"> | string | null
    createdAt?: DateTimeFilter<"EventAnalytics"> | Date | string
  }

  export type NotificationSettingsUpsertWithoutUserInput = {
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    where?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationSettingsWhereInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    notifyAtLocalTime?: StringFieldUpdateOperationsInput | string
    coldThresholdC?: FloatFieldUpdateOperationsInput | number
    hotThresholdC?: FloatFieldUpdateOperationsInput | number
    tempChangeThresholdC?: FloatFieldUpdateOperationsInput | number
    notifyOnWeatherChange?: BoolFieldUpdateOperationsInput | boolean
    minHoursBetweenNotifs?: IntFieldUpdateOperationsInput | number
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type HelpCenterConversationUpsertWithoutUserInput = {
    update: XOR<HelpCenterConversationUpdateWithoutUserInput, HelpCenterConversationUncheckedUpdateWithoutUserInput>
    create: XOR<HelpCenterConversationCreateWithoutUserInput, HelpCenterConversationUncheckedCreateWithoutUserInput>
    where?: HelpCenterConversationWhereInput
  }

  export type HelpCenterConversationUpdateToOneWithWhereWithoutUserInput = {
    where?: HelpCenterConversationWhereInput
    data: XOR<HelpCenterConversationUpdateWithoutUserInput, HelpCenterConversationUncheckedUpdateWithoutUserInput>
  }

  export type HelpCenterConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: HelpCenterMessageUpdateManyWithoutConversationNestedInput
  }

  export type HelpCenterConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: HelpCenterMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserCreateWithoutPhotosInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPhotosInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhotosInput, UserUncheckedCreateWithoutPhotosInput>
  }

  export type UserUpsertWithoutPhotosInput = {
    update: XOR<UserUpdateWithoutPhotosInput, UserUncheckedUpdateWithoutPhotosInput>
    create: XOR<UserCreateWithoutPhotosInput, UserUncheckedCreateWithoutPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhotosInput, UserUncheckedUpdateWithoutPhotosInput>
  }

  export type UserUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutWardrobeItemsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWardrobeItemsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWardrobeItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWardrobeItemsInput, UserUncheckedCreateWithoutWardrobeItemsInput>
  }

  export type OutfitItemCreateWithoutWardrobeItemInput = {
    outfit: OutfitCreateNestedOneWithoutOutfitItemsInput
  }

  export type OutfitItemUncheckedCreateWithoutWardrobeItemInput = {
    outfitId: string
  }

  export type OutfitItemCreateOrConnectWithoutWardrobeItemInput = {
    where: OutfitItemWhereUniqueInput
    create: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput>
  }

  export type OutfitItemCreateManyWardrobeItemInputEnvelope = {
    data: OutfitItemCreateManyWardrobeItemInput | OutfitItemCreateManyWardrobeItemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWardrobeItemsInput = {
    update: XOR<UserUpdateWithoutWardrobeItemsInput, UserUncheckedUpdateWithoutWardrobeItemsInput>
    create: XOR<UserCreateWithoutWardrobeItemsInput, UserUncheckedCreateWithoutWardrobeItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWardrobeItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWardrobeItemsInput, UserUncheckedUpdateWithoutWardrobeItemsInput>
  }

  export type UserUpdateWithoutWardrobeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWardrobeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OutfitItemUpsertWithWhereUniqueWithoutWardrobeItemInput = {
    where: OutfitItemWhereUniqueInput
    update: XOR<OutfitItemUpdateWithoutWardrobeItemInput, OutfitItemUncheckedUpdateWithoutWardrobeItemInput>
    create: XOR<OutfitItemCreateWithoutWardrobeItemInput, OutfitItemUncheckedCreateWithoutWardrobeItemInput>
  }

  export type OutfitItemUpdateWithWhereUniqueWithoutWardrobeItemInput = {
    where: OutfitItemWhereUniqueInput
    data: XOR<OutfitItemUpdateWithoutWardrobeItemInput, OutfitItemUncheckedUpdateWithoutWardrobeItemInput>
  }

  export type OutfitItemUpdateManyWithWhereWithoutWardrobeItemInput = {
    where: OutfitItemScalarWhereInput
    data: XOR<OutfitItemUpdateManyMutationInput, OutfitItemUncheckedUpdateManyWithoutWardrobeItemInput>
  }

  export type OutfitItemScalarWhereInput = {
    AND?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
    OR?: OutfitItemScalarWhereInput[]
    NOT?: OutfitItemScalarWhereInput | OutfitItemScalarWhereInput[]
    outfitId?: StringFilter<"OutfitItem"> | string
    wardrobeItemId?: StringFilter<"OutfitItem"> | string
  }

  export type UserCreateWithoutOutfitsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOutfitsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOutfitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
  }

  export type OutfitItemCreateWithoutOutfitInput = {
    wardrobeItem: WardrobeItemCreateNestedOneWithoutOutfitItemsInput
  }

  export type OutfitItemUncheckedCreateWithoutOutfitInput = {
    wardrobeItemId: string
  }

  export type OutfitItemCreateOrConnectWithoutOutfitInput = {
    where: OutfitItemWhereUniqueInput
    create: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput>
  }

  export type OutfitItemCreateManyOutfitInputEnvelope = {
    data: OutfitItemCreateManyOutfitInput | OutfitItemCreateManyOutfitInput[]
    skipDuplicates?: boolean
  }

  export type RenderJobCreateWithoutOutfitInput = {
    id?: string
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRenderJobsInput
  }

  export type RenderJobUncheckedCreateWithoutOutfitInput = {
    id?: string
    userId: string
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RenderJobCreateOrConnectWithoutOutfitInput = {
    where: RenderJobWhereUniqueInput
    create: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput>
  }

  export type RenderJobCreateManyOutfitInputEnvelope = {
    data: RenderJobCreateManyOutfitInput | RenderJobCreateManyOutfitInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOutfitsInput = {
    update: XOR<UserUpdateWithoutOutfitsInput, UserUncheckedUpdateWithoutOutfitsInput>
    create: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOutfitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOutfitsInput, UserUncheckedUpdateWithoutOutfitsInput>
  }

  export type UserUpdateWithoutOutfitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutfitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OutfitItemUpsertWithWhereUniqueWithoutOutfitInput = {
    where: OutfitItemWhereUniqueInput
    update: XOR<OutfitItemUpdateWithoutOutfitInput, OutfitItemUncheckedUpdateWithoutOutfitInput>
    create: XOR<OutfitItemCreateWithoutOutfitInput, OutfitItemUncheckedCreateWithoutOutfitInput>
  }

  export type OutfitItemUpdateWithWhereUniqueWithoutOutfitInput = {
    where: OutfitItemWhereUniqueInput
    data: XOR<OutfitItemUpdateWithoutOutfitInput, OutfitItemUncheckedUpdateWithoutOutfitInput>
  }

  export type OutfitItemUpdateManyWithWhereWithoutOutfitInput = {
    where: OutfitItemScalarWhereInput
    data: XOR<OutfitItemUpdateManyMutationInput, OutfitItemUncheckedUpdateManyWithoutOutfitInput>
  }

  export type RenderJobUpsertWithWhereUniqueWithoutOutfitInput = {
    where: RenderJobWhereUniqueInput
    update: XOR<RenderJobUpdateWithoutOutfitInput, RenderJobUncheckedUpdateWithoutOutfitInput>
    create: XOR<RenderJobCreateWithoutOutfitInput, RenderJobUncheckedCreateWithoutOutfitInput>
  }

  export type RenderJobUpdateWithWhereUniqueWithoutOutfitInput = {
    where: RenderJobWhereUniqueInput
    data: XOR<RenderJobUpdateWithoutOutfitInput, RenderJobUncheckedUpdateWithoutOutfitInput>
  }

  export type RenderJobUpdateManyWithWhereWithoutOutfitInput = {
    where: RenderJobScalarWhereInput
    data: XOR<RenderJobUpdateManyMutationInput, RenderJobUncheckedUpdateManyWithoutOutfitInput>
  }

  export type OutfitCreateWithoutOutfitItemsInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    renderJobs?: RenderJobCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutOutfitItemsInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutOutfitItemsInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutOutfitItemsInput, OutfitUncheckedCreateWithoutOutfitItemsInput>
  }

  export type WardrobeItemCreateWithoutOutfitItemsInput = {
    id?: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWardrobeItemsInput
  }

  export type WardrobeItemUncheckedCreateWithoutOutfitItemsInput = {
    id?: string
    userId: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardrobeItemCreateOrConnectWithoutOutfitItemsInput = {
    where: WardrobeItemWhereUniqueInput
    create: XOR<WardrobeItemCreateWithoutOutfitItemsInput, WardrobeItemUncheckedCreateWithoutOutfitItemsInput>
  }

  export type OutfitUpsertWithoutOutfitItemsInput = {
    update: XOR<OutfitUpdateWithoutOutfitItemsInput, OutfitUncheckedUpdateWithoutOutfitItemsInput>
    create: XOR<OutfitCreateWithoutOutfitItemsInput, OutfitUncheckedCreateWithoutOutfitItemsInput>
    where?: OutfitWhereInput
  }

  export type OutfitUpdateToOneWithWhereWithoutOutfitItemsInput = {
    where?: OutfitWhereInput
    data: XOR<OutfitUpdateWithoutOutfitItemsInput, OutfitUncheckedUpdateWithoutOutfitItemsInput>
  }

  export type OutfitUpdateWithoutOutfitItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    renderJobs?: RenderJobUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutOutfitItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renderJobs?: RenderJobUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type WardrobeItemUpsertWithoutOutfitItemsInput = {
    update: XOR<WardrobeItemUpdateWithoutOutfitItemsInput, WardrobeItemUncheckedUpdateWithoutOutfitItemsInput>
    create: XOR<WardrobeItemCreateWithoutOutfitItemsInput, WardrobeItemUncheckedCreateWithoutOutfitItemsInput>
    where?: WardrobeItemWhereInput
  }

  export type WardrobeItemUpdateToOneWithWhereWithoutOutfitItemsInput = {
    where?: WardrobeItemWhereInput
    data: XOR<WardrobeItemUpdateWithoutOutfitItemsInput, WardrobeItemUncheckedUpdateWithoutOutfitItemsInput>
  }

  export type WardrobeItemUpdateWithoutOutfitItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWardrobeItemsNestedInput
  }

  export type WardrobeItemUncheckedUpdateWithoutOutfitItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRenderJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRenderJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRenderJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRenderJobsInput, UserUncheckedCreateWithoutRenderJobsInput>
  }

  export type OutfitCreateWithoutRenderJobsInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    outfitItems?: OutfitItemCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutRenderJobsInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outfitItems?: OutfitItemUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutRenderJobsInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutRenderJobsInput, OutfitUncheckedCreateWithoutRenderJobsInput>
  }

  export type UserUpsertWithoutRenderJobsInput = {
    update: XOR<UserUpdateWithoutRenderJobsInput, UserUncheckedUpdateWithoutRenderJobsInput>
    create: XOR<UserCreateWithoutRenderJobsInput, UserUncheckedCreateWithoutRenderJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRenderJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRenderJobsInput, UserUncheckedUpdateWithoutRenderJobsInput>
  }

  export type UserUpdateWithoutRenderJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRenderJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OutfitUpsertWithoutRenderJobsInput = {
    update: XOR<OutfitUpdateWithoutRenderJobsInput, OutfitUncheckedUpdateWithoutRenderJobsInput>
    create: XOR<OutfitCreateWithoutRenderJobsInput, OutfitUncheckedCreateWithoutRenderJobsInput>
    where?: OutfitWhereInput
  }

  export type OutfitUpdateToOneWithWhereWithoutRenderJobsInput = {
    where?: OutfitWhereInput
    data: XOR<OutfitUpdateWithoutRenderJobsInput, OutfitUncheckedUpdateWithoutRenderJobsInput>
  }

  export type OutfitUpdateWithoutRenderJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    outfitItems?: OutfitItemUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutRenderJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type UserCreateWithoutCreditsLedgerInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditsLedgerInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditsLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditsLedgerInput, UserUncheckedCreateWithoutCreditsLedgerInput>
  }

  export type UserUpsertWithoutCreditsLedgerInput = {
    update: XOR<UserUpdateWithoutCreditsLedgerInput, UserUncheckedUpdateWithoutCreditsLedgerInput>
    create: XOR<UserCreateWithoutCreditsLedgerInput, UserUncheckedCreateWithoutCreditsLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditsLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditsLedgerInput, UserUncheckedUpdateWithoutCreditsLedgerInput>
  }

  export type UserUpdateWithoutCreditsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PurchaseCreateWithoutSubscriptionInput = {
    id?: string
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutSubscriptionInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type PurchaseCreateManySubscriptionInputEnvelope = {
    data: PurchaseCreateManySubscriptionInput | PurchaseCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PurchaseUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutSubscriptionInput, PurchaseUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PurchaseCreateWithoutSubscriptionInput, PurchaseUncheckedCreateWithoutSubscriptionInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutSubscriptionInput, PurchaseUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type SubscriptionCreateWithoutPurchasesInput = {
    id?: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPurchasesInput = {
    id?: string
    userId: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPurchasesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPurchasesInput, SubscriptionUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutPurchasesInput = {
    update: XOR<SubscriptionUpdateWithoutPurchasesInput, SubscriptionUncheckedUpdateWithoutPurchasesInput>
    create: XOR<SubscriptionCreateWithoutPurchasesInput, SubscriptionUncheckedCreateWithoutPurchasesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPurchasesInput, SubscriptionUncheckedUpdateWithoutPurchasesInput>
  }

  export type SubscriptionUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUsageRecordsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageRecordsInput, UserUncheckedCreateWithoutUsageRecordsInput>
  }

  export type UserUpsertWithoutUsageRecordsInput = {
    update: XOR<UserUpdateWithoutUsageRecordsInput, UserUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<UserCreateWithoutUsageRecordsInput, UserUncheckedCreateWithoutUsageRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageRecordsInput, UserUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type UserUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutEventsAnalyticsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsAnalyticsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsAnalyticsInput, UserUncheckedCreateWithoutEventsAnalyticsInput>
  }

  export type UserUpsertWithoutEventsAnalyticsInput = {
    update: XOR<UserUpdateWithoutEventsAnalyticsInput, UserUncheckedUpdateWithoutEventsAnalyticsInput>
    create: XOR<UserCreateWithoutEventsAnalyticsInput, UserUncheckedCreateWithoutEventsAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsAnalyticsInput, UserUncheckedUpdateWithoutEventsAnalyticsInput>
  }

  export type UserUpdateWithoutEventsAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutHelpCenterConversationInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHelpCenterConversationInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHelpCenterConversationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelpCenterConversationInput, UserUncheckedCreateWithoutHelpCenterConversationInput>
  }

  export type HelpCenterMessageCreateWithoutConversationInput = {
    id?: string
    sender: string
    text: string
    createdAt?: Date | string
  }

  export type HelpCenterMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    sender: string
    text: string
    createdAt?: Date | string
  }

  export type HelpCenterMessageCreateOrConnectWithoutConversationInput = {
    where: HelpCenterMessageWhereUniqueInput
    create: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput>
  }

  export type HelpCenterMessageCreateManyConversationInputEnvelope = {
    data: HelpCenterMessageCreateManyConversationInput | HelpCenterMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHelpCenterConversationInput = {
    update: XOR<UserUpdateWithoutHelpCenterConversationInput, UserUncheckedUpdateWithoutHelpCenterConversationInput>
    create: XOR<UserCreateWithoutHelpCenterConversationInput, UserUncheckedCreateWithoutHelpCenterConversationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelpCenterConversationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelpCenterConversationInput, UserUncheckedUpdateWithoutHelpCenterConversationInput>
  }

  export type UserUpdateWithoutHelpCenterConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHelpCenterConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HelpCenterMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: HelpCenterMessageWhereUniqueInput
    update: XOR<HelpCenterMessageUpdateWithoutConversationInput, HelpCenterMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<HelpCenterMessageCreateWithoutConversationInput, HelpCenterMessageUncheckedCreateWithoutConversationInput>
  }

  export type HelpCenterMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: HelpCenterMessageWhereUniqueInput
    data: XOR<HelpCenterMessageUpdateWithoutConversationInput, HelpCenterMessageUncheckedUpdateWithoutConversationInput>
  }

  export type HelpCenterMessageUpdateManyWithWhereWithoutConversationInput = {
    where: HelpCenterMessageScalarWhereInput
    data: XOR<HelpCenterMessageUpdateManyMutationInput, HelpCenterMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type HelpCenterMessageScalarWhereInput = {
    AND?: HelpCenterMessageScalarWhereInput | HelpCenterMessageScalarWhereInput[]
    OR?: HelpCenterMessageScalarWhereInput[]
    NOT?: HelpCenterMessageScalarWhereInput | HelpCenterMessageScalarWhereInput[]
    id?: StringFilter<"HelpCenterMessage"> | string
    conversationId?: StringFilter<"HelpCenterMessage"> | string
    sender?: StringFilter<"HelpCenterMessage"> | string
    text?: StringFilter<"HelpCenterMessage"> | string
    createdAt?: DateTimeFilter<"HelpCenterMessage"> | Date | string
  }

  export type HelpCenterConversationCreateWithoutMessagesInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHelpCenterConversationInput
  }

  export type HelpCenterConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCenterConversationCreateOrConnectWithoutMessagesInput = {
    where: HelpCenterConversationWhereUniqueInput
    create: XOR<HelpCenterConversationCreateWithoutMessagesInput, HelpCenterConversationUncheckedCreateWithoutMessagesInput>
  }

  export type HelpCenterConversationUpsertWithoutMessagesInput = {
    update: XOR<HelpCenterConversationUpdateWithoutMessagesInput, HelpCenterConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<HelpCenterConversationCreateWithoutMessagesInput, HelpCenterConversationUncheckedCreateWithoutMessagesInput>
    where?: HelpCenterConversationWhereInput
  }

  export type HelpCenterConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: HelpCenterConversationWhereInput
    data: XOR<HelpCenterConversationUpdateWithoutMessagesInput, HelpCenterConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type HelpCenterConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHelpCenterConversationNestedInput
  }

  export type HelpCenterConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    usageRecords?: UsageCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    helpCenterConversation?: HelpCenterConversationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    avatarBaseImageUrl?: string | null
    onboardingStatus?: string
    sex?: string | null
    age?: number | null
    heightCm?: number | null
    emailVerificationCode?: string | null
    emailVerificationExpires?: Date | string | null
    emailVerifiedAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    wardrobeItems?: WardrobeItemUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    renderJobs?: RenderJobUncheckedCreateNestedManyWithoutUserInput
    creditsLedger?: CreditsLedgerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    usageRecords?: UsageUncheckedCreateNestedManyWithoutUserInput
    eventsAnalytics?: EventAnalyticsUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    helpCenterConversation?: HelpCenterConversationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarBaseImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingStatus?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    heightCm?: NullableIntFieldUpdateOperationsInput | number | null
    emailVerificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    wardrobeItems?: WardrobeItemUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutUserNestedInput
    creditsLedger?: CreditsLedgerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    usageRecords?: UsageUncheckedUpdateManyWithoutUserNestedInput
    eventsAnalytics?: EventAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    helpCenterConversation?: HelpCenterConversationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserPhotoCreateManyUserInput = {
    id?: string
    imageUrl: string
    isPrimary?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardrobeItemCreateManyUserInput = {
    id?: string
    imageUrl: string
    cutoutImageUrl?: string | null
    cutoutStatus?: string
    cutoutError?: string | null
    category?: string
    colorFamily?: string
    colorHex?: string | null
    styleTags?: string
    seasonTags?: string
    fitTag?: string
    extraTags?: string | null
    confidence?: string
    rawAiJson?: string | null
    userNotes?: string | null
    productType?: string | null
    color?: string | null
    tags?: string | null
    brand?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutfitCreateManyUserInput = {
    id?: string
    weekStartDate: Date | string
    dayIndex: number
    status?: string
    imageUrl?: string | null
    promptVersion?: string | null
    weather?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RenderJobCreateManyUserInput = {
    id?: string
    outfitId?: string | null
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditsLedgerCreateManyUserInput = {
    id?: string
    delta: number
    reason: string
    refId?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    plan: string
    status?: string
    platform?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    appleOriginalTransactionId?: string | null
    appleProductId?: string | null
    appleReceiptData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyUserInput = {
    id?: string
    subscriptionId?: string | null
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCreateManyUserInput = {
    id?: string
    month: string
    aiGenerationsCount?: number
    virtualTryonCount?: number
    weeklyGenerationCount?: number
    createdAt?: Date | string
  }

  export type EventAnalyticsCreateManyUserInput = {
    id?: string
    eventName: string
    props?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhotoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardrobeItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUpdateManyWithoutWardrobeItemNestedInput
  }

  export type WardrobeItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUncheckedUpdateManyWithoutWardrobeItemNestedInput
  }

  export type WardrobeItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    cutoutImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cutoutStatus?: StringFieldUpdateOperationsInput | string
    cutoutError?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colorFamily?: StringFieldUpdateOperationsInput | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    styleTags?: StringFieldUpdateOperationsInput | string
    seasonTags?: StringFieldUpdateOperationsInput | string
    fitTag?: StringFieldUpdateOperationsInput | string
    extraTags?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: StringFieldUpdateOperationsInput | string
    rawAiJson?: NullableStringFieldUpdateOperationsInput | string | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUpdateManyWithoutOutfitNestedInput
    renderJobs?: RenderJobUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitItems?: OutfitItemUncheckedUpdateManyWithoutOutfitNestedInput
    renderJobs?: RenderJobUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dayIndex?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptVersion?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RenderJobUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outfit?: OutfitUpdateOneWithoutRenderJobsNestedInput
  }

  export type RenderJobUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    outfitId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RenderJobUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    outfitId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsLedgerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    delta?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    appleOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    appleProductId?: NullableStringFieldUpdateOperationsInput | string | null
    appleReceiptData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    aiGenerationsCount?: IntFieldUpdateOperationsInput | number
    virtualTryonCount?: IntFieldUpdateOperationsInput | number
    weeklyGenerationCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAnalyticsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    props?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitItemCreateManyWardrobeItemInput = {
    outfitId: string
  }

  export type OutfitItemUpdateWithoutWardrobeItemInput = {
    outfit?: OutfitUpdateOneRequiredWithoutOutfitItemsNestedInput
  }

  export type OutfitItemUncheckedUpdateWithoutWardrobeItemInput = {
    outfitId?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitItemUncheckedUpdateManyWithoutWardrobeItemInput = {
    outfitId?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitItemCreateManyOutfitInput = {
    wardrobeItemId: string
  }

  export type RenderJobCreateManyOutfitInput = {
    id?: string
    userId: string
    status?: string
    attempts?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutfitItemUpdateWithoutOutfitInput = {
    wardrobeItem?: WardrobeItemUpdateOneRequiredWithoutOutfitItemsNestedInput
  }

  export type OutfitItemUncheckedUpdateWithoutOutfitInput = {
    wardrobeItemId?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitItemUncheckedUpdateManyWithoutOutfitInput = {
    wardrobeItemId?: StringFieldUpdateOperationsInput | string
  }

  export type RenderJobUpdateWithoutOutfitInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRenderJobsNestedInput
  }

  export type RenderJobUncheckedUpdateWithoutOutfitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RenderJobUncheckedUpdateManyWithoutOutfitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManySubscriptionInput = {
    id?: string
    userId: string
    platform: string
    externalId: string
    productId: string
    plan: string
    status?: string
    amountCents?: number | null
    currency?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageCreateManyConversationInput = {
    id?: string
    sender: string
    text: string
    createdAt?: Date | string
  }

  export type HelpCenterMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCenterMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardrobeItemCountOutputTypeDefaultArgs instead
     */
    export type WardrobeItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardrobeItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutfitCountOutputTypeDefaultArgs instead
     */
    export type OutfitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutfitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCenterConversationCountOutputTypeDefaultArgs instead
     */
    export type HelpCenterConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCenterConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPhotoDefaultArgs instead
     */
    export type UserPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardrobeItemDefaultArgs instead
     */
    export type WardrobeItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardrobeItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutfitDefaultArgs instead
     */
    export type OutfitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutfitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutfitItemDefaultArgs instead
     */
    export type OutfitItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutfitItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RenderJobDefaultArgs instead
     */
    export type RenderJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RenderJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreditsLedgerDefaultArgs instead
     */
    export type CreditsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreditsLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageDefaultArgs instead
     */
    export type UsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventAnalyticsDefaultArgs instead
     */
    export type EventAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCenterConversationDefaultArgs instead
     */
    export type HelpCenterConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCenterConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCenterMessageDefaultArgs instead
     */
    export type HelpCenterMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCenterMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSettingsDefaultArgs instead
     */
    export type NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}